<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wireframe City Shooter</title>
<style>
  :root {
    color-scheme: dark;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: radial-gradient(circle at 50% 35%, #001636 0%, #02060d 60%, #01030a 100%);
    font-family: "Helvetica Neue", system-ui, sans-serif;
    color: #cbe7ff;
  }
  #hud {
    position: fixed;
    top: 16px;
    left: 16px;
    font-size: 13px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    opacity: 0.85;
    pointer-events: none;
  }
  #soundMode {
    position: fixed;
    top: 16px;
    right: 16px;
    display: flex;
    gap: 8px;
    z-index: 100;
  }
  .mode-btn {
    padding: 8px 16px;
    background: rgba(0, 50, 120, 0.8);
    border: 1px solid rgba(100, 200, 255, 0.5);
    color: #cbe7ff;
    font-size: 12px;
    font-family: "Helvetica Neue", system-ui, sans-serif;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .mode-btn:hover {
    background: rgba(0, 80, 180, 0.9);
    border-color: rgba(150, 220, 255, 0.7);
  }
  .mode-btn.active {
    background: rgba(0, 120, 255, 0.9);
    border-color: rgba(200, 240, 255, 0.8);
    box-shadow: 0 0 8px rgba(100, 200, 255, 0.5);
  }
  #soundTest {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 20, 60, 0.9);
    border: 1px solid rgba(100, 200, 255, 0.3);
    border-radius: 8px;
    padding: 16px;
    display: none;
    gap: 12px;
    z-index: 100;
  }
  .track-btn {
    padding: 10px 20px;
    background: rgba(0, 60, 140, 0.8);
    border: 1px solid rgba(80, 180, 255, 0.4);
    color: #cbe7ff;
    font-size: 13px;
    font-family: "Helvetica Neue", system-ui, sans-serif;
    cursor: pointer;
    transition: all 0.2s;
    border-radius: 4px;
  }
  .track-btn:hover {
    background: rgba(0, 90, 180, 0.9);
    border-color: rgba(120, 200, 255, 0.6);
  }
  .track-btn.playing {
    background: rgba(0, 140, 255, 0.9);
    border-color: rgba(180, 240, 255, 0.8);
    box-shadow: 0 0 6px rgba(100, 200, 255, 0.4);
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }
  #aiPanel {
    position: fixed;
    top: 0;
    left: 0;
    width: 150px;
    height: 100px;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    z-index: 1000;
    pointer-events: none;
  }
  #aiPanelGuide {
    position: fixed;
    top: 108px;
    left: 8px;
    max-width: 240px;
    padding: 4px 6px;
    font-size: 11px;
    line-height: 1.4;
    font-family: "Roboto Mono", "SFMono-Regular", "Menlo", monospace;
    color: #e9f5ff;
    background: rgba(0, 0, 0, 0.65);
    border: 1px solid rgba(255, 255, 255, 0.45);
    border-radius: 4px;
    letter-spacing: 0.04em;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
</style>
</head>
<body>
<canvas id="view" width="1280" height="720"></canvas>
<canvas id="aiPanel" width="150" height="100" aria-hidden="true"></canvas>
<div id="aiPanelGuide" aria-hidden="true">VISION AI KEY: H = PLAYER HP / E = NEAREST ENEMY + DIST / S = STAGE CODE / EV = EVENT CODE</div>
<div id="hud">CITY RUN / WIREFRAME MODE</div>
<div id="soundMode">
  <button class="mode-btn active" id="gameMode">Game</button>
  <button class="mode-btn" id="finalBossMode">Final Boss Test</button>
  <button class="mode-btn" id="soundModeBtn">Sound Test</button>
</div>
<div id="soundTest">
  <button class="track-btn" data-track="stage0">Stage 0 - Launch</button>
  <button class="track-btn" data-track="stage1">Stage 1 - Final Takeoff</button>
  <button class="track-btn" data-track="stage2">Stage 2 - Space Opera</button>
  <button class="track-btn" data-track="stage3">Stage 3 - Boss Battle</button>
  <button class="track-btn" data-track="clear">Clear Jingle</button>
  <button class="track-btn" data-track="ascent">Space Ascent SFX</button>
</div>
<script>
(() => {
  "use strict";
  const canvas = document.getElementById("view");
  const ctx = canvas.getContext("2d", { alpha: false });
  const hudLabel = document.getElementById("hud");
  const aiPanelCanvas = document.getElementById("aiPanel");
  const aiPanelCtx = aiPanelCanvas ? aiPanelCanvas.getContext("2d", { alpha: false }) : null;
  const aiPanelGuide = document.getElementById("aiPanelGuide");
  if (aiPanelCtx) {
    aiPanelCtx.imageSmoothingEnabled = false;
  }

  // === AIステータスパネル描画（視覚AI向け） ===
  function renderAIPanel(state) {
    if (!aiPanelCtx || !aiPanelCanvas || !state) return;
    const width = aiPanelCanvas.width;
    const height = aiPanelCanvas.height;
    aiPanelCtx.save();
    aiPanelCtx.imageSmoothingEnabled = false;
    aiPanelCtx.fillStyle = "#000";
    aiPanelCtx.fillRect(0, 0, width, height);
    aiPanelCtx.fillStyle = "#fff";
    aiPanelCtx.font = "12px \"Roboto Mono\", \"SFMono-Regular\", \"Menlo\", monospace";
    aiPanelCtx.textBaseline = "top";
    aiPanelCtx.textAlign = "left";
    const lines = [
      `H${state.hp ?? 0}`,
      `E${state.enemyId ?? "NA"}/${state.enemyDist ?? 0}`,
      `S${state.stage ?? "??"}`,
      `EV${state.event ?? 0}`,
    ];
    for (let i = 0; i < lines.length; i++) {
      aiPanelCtx.fillText(lines[i], 8, 8 + i * 20);
    }
    aiPanelCtx.restore();
  }

  // === ゲーム開始時にVision AI用説明を点灯 ===
  function updateAIPanelGuideVisibility() {
    if (!aiPanelGuide) return;
    const shouldShow = gamePhase === "stage0" && phaseTime < 12;
    aiPanelGuide.style.opacity = shouldShow ? "0.95" : "0";
  }

  // === 表示設定 ===
  const display = {
    fov: 1.2,          // 遠近感の強さ
    zNear: 1.0,        // ニアクリップ
    zFar: 4000.0,      // ファークリップ
    filmHeight: 1.0,   // 正規化されたフィルムサイズ
  };

  // === 入力状態 ===
  const keys = new Set();
  window.addEventListener("keydown", (ev) => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space", "KeyW", "KeyA", "KeyS", "KeyD"].includes(ev.code)) {
      ev.preventDefault();
    }
    keys.add(ev.code);
    if (!ev.repeat && ev.code === "KeyF") {
      missileRequest = true; // ミサイルは単発入力で発射要求
    }
    if (!ev.repeat) {
      recordRollInput(ev.code);
    }
  }, { passive: false });
  window.addEventListener("keyup", (ev) => keys.delete(ev.code));

  // === ローリング入力管理 ===
  const rollComboPattern = ["ArrowRight", "ArrowLeft", "ArrowRight"];
  const rollInputBuffer = [];
  const rollState = {
    active: false,
    direction: 1,
    timer: 0,
    duration: 0.75,
    cooldown: 0,
    cooldownDuration: 0.45,
    rotationAngle: Math.PI * 2,
    maxIntervalMs: 220,
  };

  function recordRollInput(code) {
    // →←→のテンポ入力だけを監視してローリング発動を判定
    if (code !== "ArrowLeft" && code !== "ArrowRight") {
      return;
    }
    const now = performance.now();
    rollInputBuffer.push({ code, time: now });
    const bufferLimit = rollComboPattern.length;
    const expiry = rollState.maxIntervalMs * rollComboPattern.length;
    while (rollInputBuffer.length && now - rollInputBuffer[0].time > expiry) {
      rollInputBuffer.shift();
    }
    while (rollInputBuffer.length > bufferLimit) {
      rollInputBuffer.shift();
    }
    if (!canTriggerPlayerRoll() || rollState.active || rollState.cooldown > 0) {
      return;
    }
    if (rollInputBuffer.length < rollComboPattern.length) {
      return;
    }
    let tempoOk = true;
    for (let i = 1; i < rollInputBuffer.length; i++) {
      if (rollInputBuffer[i].time - rollInputBuffer[i - 1].time > rollState.maxIntervalMs) {
        tempoOk = false;
        break;
      }
    }
    if (!tempoOk) return;
    for (let i = 0; i < rollComboPattern.length; i++) {
      if (rollInputBuffer[i].code !== rollComboPattern[i]) {
        return;
      }
    }
    const direction = rollComboPattern[rollComboPattern.length - 1] === "ArrowLeft" ? -1 : 1;
    rollInputBuffer.length = 0;
    startPlayerRoll(direction);
  }

  function canTriggerPlayerRoll() {
    // 自機操作可能なフェーズのみ判定
    if (!player.visible || gameOver) return false;
    return ["stage1", "cityExit", "stage2", "finalBoss", "finalClear"].includes(gamePhase);
  }

  function startPlayerRoll(direction) {
    // ローリング状態の初期化
    rollState.active = true;
    rollState.direction = direction;
    rollState.timer = rollState.duration;
    rollState.cooldown = rollState.duration + rollState.cooldownDuration;
    player.invuln = Math.max(player.invuln, rollState.duration);
    camera.shake = Math.max(camera.shake, 0.7);
  }

  // === オーディオ制御 ===
  const AudioContextClass = window.AudioContext || window.webkitAudioContext;
  let audioController = null;
  let stage0JinglePending = false;
  let stage0JinglePlayed = false;
  let stage0JingleStartTime = 0;
  let stage1MusicPending = false;
  let stage1MusicActive = false;
  let stage2MusicPending = false;
  let stage2MusicActive = false;
  let stage3MusicPending = false;
  let stage3MusicActive = false;
  let cityFanfarePending = false;

  function ensureAudioController() {
    if (audioController || !AudioContextClass) {
      return audioController;
    }
    audioController = createAudioController();
    return audioController;
  }

  function queueStage0Jingle() {
    // ステージ0開幕用ジングル再生の準備と即時試行
    stopStageMusic();
    stage0JinglePending = true;
    stage0JinglePlayed = false;
    stage0JingleStartTime = 0;
    tryPlayStage0Jingle();
    setTimeout(() => {
      if (stage0JinglePending && !stage0JinglePlayed) {
        tryPlayStage0Jingle();
      }
    }, 140);
    resumeAudioContext();
  }

  async function resumeAudioContext() {
    // ユーザー操作時にサスペンド解除してジングル発火を保証
    const controller = ensureAudioController();
    if (!controller) return;
    try {
      if (controller.context.state === "suspended") {
        await controller.context.resume();
      }
      tryPlayStage0Jingle();
      tryPlayStage1Music();
      tryPlayStage2Music();
      tryPlayStage3Music();
      tryPlayCityExitFanfare();
    } catch (err) {
      console.warn("Audio resume failed", err);
    }
  }

  function tryPlayStage0Jingle() {
    // コンテキストが稼働中なら即座にジングル開始
    if (!stage0JinglePending || stage0JinglePlayed) return;
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") return;
    try {
      controller.playStage0Jingle();
      stage0JinglePending = false;
      stage0JinglePlayed = true;
      stage0JingleStartTime = controller.context.currentTime;
    } catch (err) {
      console.warn("Stage0 jingle play failed", err);
      stage0JinglePending = true;
      stage0JinglePlayed = false;
    }
  }

  const audioGestureEvents = ["pointerdown", "touchstart", "keydown"];
  for (const type of audioGestureEvents) {
    window.addEventListener(type, resumeAudioContext, { passive: true });
  }
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      resumeAudioContext();
    }
  });

  function handleAudioStateChange() {
    if (!audioController) return;
    if (audioController.context.state === "running") {
      tryPlayStage0Jingle();
      tryPlayStage1Music();
      tryPlayStage2Music();
      tryPlayStage3Music();
      tryPlayCityExitFanfare();
    }
  }

  function queueStage1Music() {
    // ステージ1突入時のアフターバーナー調BGMを保留して試行
    stage1MusicPending = true;
    stage1MusicActive = false;
    tryPlayStage1Music();
  }

  function tryPlayStage1Music() {
    // オーディオコンテキストが稼働したら即座に再生開始
    if (!stage1MusicPending || stage1MusicActive) return;
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") return;
    controller.playStage1Theme();
    stage1MusicPending = false;
    stage1MusicActive = true;
  }

  function queueStage2Music() {
    // 宇宙ステージ用オペラ調テーマの再生要求をセット
    stage2MusicPending = true;
    stage2MusicActive = false;
    tryPlayStage2Music();
  }

  function tryPlayStage2Music() {
    // オーディオが動作中なら宇宙テーマを即再生
    if (!stage2MusicPending || stage2MusicActive) return;
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") return;
    controller.playStage2Theme();
    stage2MusicPending = false;
    stage2MusicActive = true;
  }

  function queueStage3Music() {
    // ボス戦テーマの再生要求をセット
    if (stage3MusicPending || stage3MusicActive) return;
    if (stage1MusicActive || stage2MusicActive) {
      stopStageMusic();
    }
    stage3MusicPending = true;
    stage3MusicActive = false;
    tryPlayStage3Music();
  }

  function tryPlayStage3Music() {
    // オーディオが稼働していればボステーマを再生
    if (!stage3MusicPending || stage3MusicActive) return;
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") return;
    controller.playStage3Theme();
    stage3MusicPending = false;
    stage3MusicActive = true;
  }

  function queueCityExitFanfare() {
    // ファンファーレ再生の保留をセット
    cityFanfarePending = true;
    tryPlayCityExitFanfare();
  }

  function tryPlayCityExitFanfare() {
    // コンテキスト稼働中ならファンファーレを即再生
    if (!cityFanfarePending) return;
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") return;
    controller.playCityExitFanfare();
    cityFanfarePending = false;
  }

  function stopStageMusic() {
    // ステージBGMを停止し、待機フラグも解除
    stage1MusicPending = false;
    stage1MusicActive = false;
    stage2MusicPending = false;
    stage2MusicActive = false;
    stage3MusicPending = false;
    stage3MusicActive = false;
    cityFanfarePending = false;
    if (!audioController) return;
    audioController.stopStageMusic();
  }

  function triggerLaserSfx(kind = "player") {
    // レーザーSE再生をラップ（サスペンド中は再開要求）
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") {
      resumeAudioContext();
      return;
    }
    controller.playLaserSfx(kind);
  }

  function triggerExplosionSfx(intensity = 1) {
    // 爆発SE再生ラッパー（スケールに応じて音量補正）
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") {
      resumeAudioContext();
      return;
    }
    controller.playExplosionSfx(intensity);
  }

  function triggerShieldFixSfx() {
    // シールド回復時の明るい効果音を再生
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") {
      resumeAudioContext();
      return;
    }
    if (typeof controller.playShieldFixSfx === "function") {
      controller.playShieldFixSfx();
    }
  }

  function triggerSpaceAscentSfx(progress = 0) {
    const controller = ensureAudioController();
    if (!controller) return;
    if (controller.context.state !== "running") {
      resumeAudioContext();
      return;
    }
    controller.playSpaceAscentSfx(progress);
  }

  function triggerCityExitFanfare() {
    // ファンファーレ再生を試行（未再生なら待機）
    queueCityExitFanfare();
  }

  function createAudioController() {
    // YM2612風FMとSN76489風PSGを束ねるWebAudioコンテナ
    if (!AudioContextClass) return null;
    const context = new AudioContextClass({ latencyHint: "interactive" });
    const masterGain = context.createGain();
    masterGain.gain.value = 0.55;
    const compressor = context.createDynamicsCompressor();
    // FMピークの音割れを抑えるために軽いダイナミクス処理を挿入
    compressor.threshold.setValueAtTime(-22, context.currentTime);
    compressor.knee.setValueAtTime(18, context.currentTime);
    compressor.ratio.setValueAtTime(4, context.currentTime);
    compressor.attack.setValueAtTime(0.004, context.currentTime);
    compressor.release.setValueAtTime(0.28, context.currentTime);
    masterGain.connect(compressor);
    compressor.connect(context.destination);

    context.addEventListener("statechange", handleAudioStateChange);

    const fmBus = context.createGain();
    fmBus.gain.value = 0.88;
    
    // エレキギター用ディストーションエフェクト
    const distortion = context.createWaveShaper();
    distortion.curve = makeDistortionCurve(18);
    distortion.oversample = '2x';
    
    const distortionGain = context.createGain();
    distortionGain.gain.value = 0.28;
    
    const distortionMix = context.createGain();
    distortionMix.gain.value = 0.22;
    
    // ディストーション処理
    fmBus.connect(distortion);
    distortion.connect(distortionGain);
    distortionGain.connect(distortionMix);
    distortionMix.connect(masterGain);
    
    // クリーン信号も混ぜる
    const cleanGain = context.createGain();
    cleanGain.gain.value = 0.82;
    fmBus.connect(cleanGain);
    cleanGain.connect(masterGain);

    function makeDistortionCurve(amount) {
      const samples = 44100;
      const curve = new Float32Array(samples);
      const deg = Math.PI / 180;
      for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
      }
      return curve;
    }

    const psgBus = context.createGain();
    psgBus.gain.value = 0.26;
    psgBus.connect(masterGain);

    const sfxBus = context.createGain();
    sfxBus.gain.value = 0.92; // SEを前面に押し出すブーストレベル
    sfxBus.connect(masterGain);

    const noiseBuffer = createNoiseBuffer();
    const activeNodes = new Set();
    const musicTimers = new Set();
    let musicMode = null;

    function track(node) {
      if (!node) return node;
      activeNodes.add(node);
      const dispose = () => activeNodes.delete(node);
      if (typeof node.addEventListener === "function") {
        node.addEventListener("ended", dispose, { once: true });
      } else if ("onended" in node) {
        const prev = node.onended;
        node.onended = (...args) => {
          if (typeof prev === "function") prev.apply(node, args);
          dispose();
        };
      }
      return node;
    }

    function stopActiveNodes() {
      const now = context.currentTime;
      for (const node of activeNodes) {
        try {
          if (node.stop) {
            node.stop(now + 0.01);
          }
        } catch (err) {
          console.warn("stop failed", err);
        }
      }
      activeNodes.clear();
    }

    function scheduleMusicTimer(callback, delayMs) {
      const id = setTimeout(() => {
        musicTimers.delete(id);
        callback();
      }, delayMs);
      musicTimers.add(id);
      return id;
    }

    function clearMusicTimers() {
      for (const id of musicTimers) {
        clearTimeout(id);
      }
      musicTimers.clear();
    }

    function stopStageMusicInternal() {
      clearMusicTimers();
      musicMode = null;
      stopActiveNodes();
    }

    function createNoiseBuffer() {
      const buffer = context.createBuffer(1, context.sampleRate, context.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      return buffer;
    }

    function applyEnv(param, start, peak, attack, decay, sustainLevel, release, duration) {
      // ADSRライクなエンベロープをAudioParamに適用
      const epsilon = 0.0001;
      const sustainTime = Math.max(0, duration - attack - decay - release);
      param.cancelScheduledValues(start);
      param.setValueAtTime(epsilon, start);
      param.linearRampToValueAtTime(peak, start + attack);
      param.linearRampToValueAtTime(peak * sustainLevel, start + attack + decay);
      const sustainEnd = start + attack + decay + sustainTime;
      param.setValueAtTime(peak * sustainLevel, sustainEnd);
      param.linearRampToValueAtTime(epsilon, sustainEnd + release);
    }

    function scheduleFmVoice(start, baseFreq, duration, velocity, preset) {
      // 4オペレータのFMボイスを生成（YM2612アルゴリズムのチェーン近似）
      const stopTime = start + duration + preset.releaseTail;
      const carrier = context.createOscillator();
      carrier.type = "sine";
      carrier.frequency.setValueAtTime(baseFreq * preset.ratios[0], start);
      const carrierGain = context.createGain();
      carrierGain.gain.setValueAtTime(0, start);
      carrier.connect(carrierGain);
      carrierGain.connect(fmBus);

      const opGains = [];
      let previousOp = carrier;
      for (let i = 1; i < 4; i++) {
        const osc = context.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(baseFreq * preset.ratios[i], start);
        const gain = context.createGain();
        gain.gain.setValueAtTime(0, start);
        osc.connect(gain);
        const target = preset.algorithm === "parallel" && i >= 3 ? carrier.frequency : previousOp.frequency;
        gain.connect(target);
        applyEnv(gain.gain, start, preset.modLevels[i - 1] * velocity, preset.attack[i], preset.decay[i], preset.sustain[i], preset.release[i], duration);
        osc.start(start);
        osc.stop(stopTime);
        track(osc);
        opGains.push(gain);
        previousOp = osc;
      }

      applyEnv(carrierGain.gain, start, preset.carrierLevel * velocity, preset.attack[0], preset.decay[0], preset.sustain[0], preset.release[0], duration);
      carrier.start(start);
      carrier.stop(stopTime);
      track(carrier);
      opGains.forEach(track);
      track(carrierGain);
    }

    function schedulePsgTone(start, freq, duration, level) {
      // SN76489のトーンチャンネル相当の矩形波をスケジュール
      const stopTime = start + duration + 0.12;
      const osc = context.createOscillator();
      osc.type = "square";
      osc.frequency.setValueAtTime(freq, start);
      const gain = context.createGain();
      gain.gain.setValueAtTime(0, start);
      osc.connect(gain);
      gain.connect(psgBus);
      applyEnv(gain.gain, start, level, 0.008, 0.08, 0.5, 0.1, duration);
      osc.start(start);
      osc.stop(stopTime);
      track(osc);
      track(gain);
    }

    function schedulePsgNoise(start, duration, level) {
      // PSGノイズチャンネルの疑似パルスを生成
      const stopTime = start + duration;
      const source = context.createBufferSource();
      source.buffer = noiseBuffer;
      source.loop = true;
      const gain = context.createGain();
      gain.gain.setValueAtTime(0, start);
      source.connect(gain);
      gain.connect(psgBus);
      applyEnv(gain.gain, start, level, 0.001, 0.05, 0.0, 0.08, duration);
      source.start(start);
      source.stop(stopTime);
      track(source);
      track(gain);
    }

    function scheduleKickDrum(start, velocity = 1.0) {
      // キックドラム音（低域の重い音）
      const osc = context.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(60, start);
      osc.frequency.exponentialRampToValueAtTime(30, start + 0.15);
      
      const gain = context.createGain();
      gain.gain.setValueAtTime(0, start);
      gain.gain.linearRampToValueAtTime(0.8 * velocity, start + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.001, start + 0.3);
      
      osc.connect(gain);
      gain.connect(sfxBus);
      osc.start(start);
      osc.stop(start + 0.3);
      track(osc);
      track(gain);
    }

    function scheduleSnareDrum(start, velocity = 1.0) {
      // スネアドラム音（ノイズ+トーン）
      const tone = context.createOscillator();
      tone.type = "triangle";
      tone.frequency.setValueAtTime(200, start);
      
      const noise = context.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;
      
      const toneGain = context.createGain();
      toneGain.gain.setValueAtTime(0.4 * velocity, start);
      toneGain.gain.exponentialRampToValueAtTime(0.001, start + 0.12);
      
      const noiseGain = context.createGain();
      noiseGain.gain.setValueAtTime(0.6 * velocity, start);
      noiseGain.gain.exponentialRampToValueAtTime(0.001, start + 0.08);
      
      const filter = context.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.setValueAtTime(3000, start);
      
      tone.connect(toneGain);
      toneGain.connect(sfxBus);
      
      noise.connect(filter);
      filter.connect(noiseGain);
      noiseGain.connect(sfxBus);
      
      tone.start(start);
      tone.stop(start + 0.12);
      noise.start(start);
      noise.stop(start + 0.08);
      
      track(tone);
      track(toneGain);
      track(noise);
      track(filter);
      track(noiseGain);
    }

    function scheduleHiHat(start, velocity = 1.0, duration = 0.05) {
      // ハイハット音（金属的な高域ノイズ）
      const noise = context.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;
      
      const filter = context.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.setValueAtTime(7000, start);
      filter.Q.setValueAtTime(2.0, start);
      
      const gain = context.createGain();
      gain.gain.setValueAtTime(0.3 * velocity, start);
      gain.gain.exponentialRampToValueAtTime(0.001, start + duration);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(sfxBus);
      
      noise.start(start);
      noise.stop(start + duration);
      
      track(noise);
      track(filter);
      track(gain);
    }

    function scheduleCrashCymbal(start, velocity = 1.0) {
      // クラッシュシンバル音
      const noise = context.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;
      
      const filter = context.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.setValueAtTime(5000, start);
      filter.Q.setValueAtTime(1.5, start);
      
      const gain = context.createGain();
      gain.gain.setValueAtTime(0.7 * velocity, start);
      gain.gain.exponentialRampToValueAtTime(0.001, start + 1.5);
      
      noise.connect(filter);
      filter.connect(gain);
      gain.connect(sfxBus);
      
      noise.start(start);
      noise.stop(start + 1.5);
      
      track(noise);
      track(filter);
      track(gain);
    }

    function scheduleOrchestralHit(start, velocity = 1.0) {
      // オーケストラヒット（広がりのある打楽器音）
      const osc1 = context.createOscillator();
      const osc2 = context.createOscillator();
      const osc3 = context.createOscillator();
      
      osc1.type = "sawtooth";
      osc2.type = "square"; 
      osc3.type = "triangle";
      
      osc1.frequency.setValueAtTime(80, start);
      osc2.frequency.setValueAtTime(120, start);
      osc3.frequency.setValueAtTime(160, start);
      
      const noise = context.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;
      
      const filter = context.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.setValueAtTime(2000, start);
      filter.frequency.exponentialRampToValueAtTime(8000, start + 0.3);
      
      const gain = context.createGain();
      gain.gain.setValueAtTime(0, start);
      gain.gain.linearRampToValueAtTime(1.0 * velocity, start + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, start + 2.0);
      
      osc1.connect(gain);
      osc2.connect(gain);
      osc3.connect(gain);
      noise.connect(filter);
      filter.connect(gain);
      
      gain.connect(sfxBus);
      
      osc1.start(start);
      osc2.start(start);
      osc3.start(start);
      noise.start(start);
      
      osc1.stop(start + 2.0);
      osc2.stop(start + 2.0);
      osc3.stop(start + 2.0);
      noise.stop(start + 2.0);
      
      track(osc1);
      track(osc2);
      track(osc3);
      track(noise);
      track(filter);
      track(gain);
    }

    const fmPreset = {
      // エレキギター風パワーコード設定（ノイズ抑制版）
      ratios: [1, 1.99, 2.98, 0.5],
      modLevels: [65, 48, 30],
      carrierLevel: 0.95,
      algorithm: "chain",
      attack: [0.003, 0.005, 0.008, 0.01],
      decay: [0.12, 0.18, 0.25, 0.3],
      sustain: [0.65, 0.45, 0.25, 0.15],
      release: [0.18, 0.15, 0.12, 0.1],
      releaseTail: 0.25,
    };

    const fmLead = {
      // エレキリードギター設定（歪みと共振を強化、ノイズ抑制版）
      ratios: [1, 2.01, 3.02, 0.99],
      modLevels: [60, 42, 25],
      carrierLevel: 0.88,
      algorithm: "chain",
      attack: [0.002, 0.004, 0.006, 0.008],
      decay: [0.08, 0.15, 0.22, 0.28],
      sustain: [0.55, 0.35, 0.18, 0.12],
      release: [0.22, 0.18, 0.15, 0.12],
      releaseTail: 0.3,
    };

    const psgLevels = {
      // PSG各チャンネルの相対音量
      chord: 0.14,
      arp: 0.09,
      hit: 0.18,
    };

    const NOTE_OFFSET_MAP = {
      C: -9,
      "C#": -8,
      Db: -8,
      D: -7,
      "D#": -6,
      Eb: -6,
      E: -5,
      F: -4,
      "F#": -3,
      Gb: -3,
      G: -2,
      "G#": -1,
      Ab: -1,
      A: 0,
      "A#": 1,
      Bb: 1,
      B: 2,
    };

    const DURATION_SYMBOL_MAP = {
      w: 4,
      h: 2,
      q: 1,
      e: 0.5,
      s: 0.25,
    };

    // 人間可読な音名を周波数へ変換するユーティリティ
    function noteNameToFrequency(noteName) {
      const trimmed = noteName.trim();
      if (!trimmed || trimmed.toUpperCase() === "R") {
        return null;
      }
      const match = /^([A-Ga-g])([#b]?)(-?\d)([+-]\d+)?$/.exec(trimmed);
      if (!match) {
        throw new Error(`Unsupported note format: ${noteName}`);
      }
      const letter = match[1].toUpperCase();
      const accidental = match[2] || "";
      const octave = Number(match[3]);
      const transpose = match[4] ? Number(match[4]) : 0;
      const symbol = `${letter}${accidental}`;
      const semitone = NOTE_OFFSET_MAP[symbol];
      if (semitone === undefined) {
        throw new Error(`Unknown note symbol: ${symbol}`);
      }
      const midi = (octave - 4) * 12 + semitone + transpose;
      return 440 * Math.pow(2, midi / 12);
    }

    // 音価記号を拍数へ変換するユーティリティ
    function durationSymbolToBeats(symbol) {
      if (!symbol) return 1;
      let base = symbol;
      let dots = 0;
      while (base.endsWith(".")) {
        base = base.slice(0, -1);
        dots += 1;
      }
      const primitive = DURATION_SYMBOL_MAP[base];
      if (!primitive) {
        throw new Error(`Unsupported duration symbol: ${symbol}`);
      }
      let value = primitive;
      for (let i = 0; i < dots; i++) {
        value += primitive / Math.pow(2, i + 1);
      }
      return value;
    }

    // 楽譜エントリをスケジューラへ展開する共通関数
    function renderScore(entries, beat, baseTime, options) {
      const {
        defaultGain = 1,
        preset,
        schedule,
      } = options;
      for (const entry of entries) {
        const entryOffsetBeats = entry.offsetBeats ?? 0;
        const lengthBeats = entry.lengthBeats ?? durationSymbolToBeats(entry.length || "q");
        const startTime = baseTime + entryOffsetBeats * beat;
        const duration = lengthBeats * beat;
        if (entry.notes.trim().toUpperCase() === "R") {
          continue;
        }
        const tokens = entry.notes.split(/[,\s]+/).filter(Boolean);
        for (const token of tokens) {
          const freq = noteNameToFrequency(token);
          if (freq === null) continue;
          const gain = entry.gain ?? defaultGain;
          schedule({
            startTime,
            duration,
            frequency: freq,
            gain,
            preset,
            entry,
          });
        }
      }
    }

    // ドラム（ノイズ）用のパターン記述を解釈するユーティリティ
    function renderDrumPattern(pattern, beat, baseTime, options) {
      const {
        stepsPerBeat,
        noiseGain,
        accentGainMultiplier = 1.5,
        hitSeconds,
      } = options;
      const compact = pattern.replace(/\s+/g, "");
      const stepDuration = beat / stepsPerBeat;
      for (let i = 0; i < compact.length; i++) {
        const ch = compact[i];
        if (ch === "x" || ch === "X") {
          const start = baseTime + i * stepDuration;
          const gain = ch === "X" ? noiseGain * accentGainMultiplier : noiseGain;
          const duration = hitSeconds ?? stepDuration * 0.6;
          schedulePsgNoise(start, duration, gain);
        }
      }
    }

    function renderEnhancedDrumPattern(pattern, beat, baseTime, options = {}) {
      const {
        stepsPerBeat = 2,
        velocity = 1.0,
      } = options;
      const compact = pattern.replace(/\s+/g, "");
      const stepDuration = beat / stepsPerBeat;
      
      for (let i = 0; i < compact.length; i++) {
        const ch = compact[i];
        if (ch !== '-' && ch !== '|') {
          const start = baseTime + i * stepDuration;
          const isAccent = ch === ch.toUpperCase();
          const vel = isAccent ? velocity * 1.3 : velocity;
          
          switch(ch.toLowerCase()) {
            case 'k': // Kick
              scheduleKickDrum(start, vel);
              break;
            case 's': // Snare
              scheduleSnareDrum(start, vel);
              break;
            case 'h': // Hi-hat
              scheduleHiHat(start, vel, 0.05);
              break;
            case 'c': // Crash cymbal
              scheduleCrashCymbal(start, vel);
              break;
            case 'o': // Orchestral hit
              scheduleOrchestralHit(start, vel);
              break;
            case 'x': // Legacy noise
              schedulePsgNoise(start, stepDuration * 0.6, vel * 0.5);
              break;
          }
        }
      }
    }

    // === ステージ1/2/3/4の楽譜データ（音名ベースで編集しやすい形） ===
    // Final Takeoff風離陸シーン
    const STAGE1_BEAT = 0.45;
    const STAGE1_BLOCK_BEATS = 8;
    const STAGE1_CHORD_ENTRIES = [
      { offsetBeats: 0, notes: "C4 E4 G4 C5", length: "h" },
      { offsetBeats: 2, notes: "F4 A4 C5 F5", length: "h" },
      { offsetBeats: 4, notes: "G4 B4 D5 G5", length: "h" },
      { offsetBeats: 6, notes: "C5 E5 G5 C6", length: "h" },
    ];
    const STAGE1_LEAD_ENTRIES = [
      { offsetBeats: 0, notes: "E5", lengthBeats: 0.25 },
      { offsetBeats: 0.25, notes: "G5", lengthBeats: 0.25 },
      { offsetBeats: 0.5, notes: "A5", lengthBeats: 0.25 },
      { offsetBeats: 0.75, notes: "G5", lengthBeats: 0.25 },
      { offsetBeats: 1, notes: "C6", lengthBeats: 0.5 },
      { offsetBeats: 1.5, notes: "B5", lengthBeats: 0.25 },
      { offsetBeats: 1.75, notes: "A5", lengthBeats: 0.25 },
      { offsetBeats: 2, notes: "G5", lengthBeats: 0.5 },
      { offsetBeats: 2.5, notes: "F5", lengthBeats: 0.25 },
      { offsetBeats: 2.75, notes: "E5", lengthBeats: 0.25 },
      { offsetBeats: 3, notes: "G5", lengthBeats: 0.5 },
      { offsetBeats: 3.5, notes: "E5", lengthBeats: 0.5 },
      { offsetBeats: 4, notes: "D5", lengthBeats: 0.25 },
      { offsetBeats: 4.25, notes: "F5", lengthBeats: 0.25 },
      { offsetBeats: 4.5, notes: "G5", lengthBeats: 0.5 },
      { offsetBeats: 5, notes: "B5", lengthBeats: 0.25 },
      { offsetBeats: 5.25, notes: "C6", lengthBeats: 0.25 },
      { offsetBeats: 5.5, notes: "A5", lengthBeats: 0.5 },
      { offsetBeats: 6, notes: "G5", lengthBeats: 0.25 },
      { offsetBeats: 6.25, notes: "F5", lengthBeats: 0.25 },
      { offsetBeats: 6.5, notes: "E5", lengthBeats: 0.25 },
      { offsetBeats: 6.75, notes: "D5", lengthBeats: 0.25 },
      { offsetBeats: 7, notes: "E5", lengthBeats: 0.5 },
      { offsetBeats: 7.5, notes: "C5", lengthBeats: 0.5 },
    ];
    const STAGE1_BASS_ENTRIES = [
      { offsetBeats: 0, notes: "C3", lengthBeats: 1 },
      { offsetBeats: 1, notes: "G3", lengthBeats: 1 },
      { offsetBeats: 2, notes: "F3", lengthBeats: 1 },
      { offsetBeats: 3, notes: "C4", lengthBeats: 1 },
      { offsetBeats: 4, notes: "G3", lengthBeats: 1 },
      { offsetBeats: 5, notes: "D4", lengthBeats: 1 },
      { offsetBeats: 6, notes: "E4", lengthBeats: 1 },
      { offsetBeats: 7, notes: "C4", lengthBeats: 1 },
    ];
    const STAGE1_ARP_NOTES = ["C6", "E6", "G6", "C7", "G6", "E6", "C6", "B5"];
    const STAGE1_ARP_ENTRIES = STAGE1_CHORD_ENTRIES.map((entry, idx) => ({
      offsetBeats: entry.offsetBeats + 0.1,
      lengthBeats: 0.15,
      notes: STAGE1_ARP_NOTES[idx],
    }));
    const STAGE1_DRUM_PATTERN = "K-hH|K-hH|K-hH|K-hH|K-hH|K-hH|K-hH|KChH";

    // オーケストラ風スペースオペラ（宇宙面）
    const STAGE2_BEAT = 0.65;
    const STAGE2_BLOCK_BEATS = 16;
    const STAGE2_CHORD_ENTRIES = [
      { offsetBeats: 0, notes: "D3 F#3 A3 D4", lengthBeats: 4 },
      { offsetBeats: 4, notes: "G3 B3 D4 G4", lengthBeats: 4 },
      { offsetBeats: 8, notes: "C4 E4 G4 C5", lengthBeats: 4 },
      { offsetBeats: 12, notes: "F4 A4 C5 F5", lengthBeats: 4 },
    ];
    const STAGE2_LEAD_ENTRIES = [
      { offsetBeats: 0, notes: "D5", lengthBeats: 0.5 },
      { offsetBeats: 0.5, notes: "F#5", lengthBeats: 0.5 },
      { offsetBeats: 1, notes: "A5", lengthBeats: 0.5 },
      { offsetBeats: 1.5, notes: "D6", lengthBeats: 0.5 },
      { offsetBeats: 2, notes: "C#6", lengthBeats: 0.5 },
      { offsetBeats: 2.5, notes: "B5", lengthBeats: 0.5 },
      { offsetBeats: 3, notes: "A5", lengthBeats: 0.5 },
      { offsetBeats: 3.5, notes: "F#5", lengthBeats: 0.5 },
      { offsetBeats: 4, notes: "G5", lengthBeats: 0.5 },
      { offsetBeats: 4.5, notes: "B5", lengthBeats: 0.5 },
      { offsetBeats: 5, notes: "D6", lengthBeats: 0.5 },
      { offsetBeats: 5.5, notes: "G6", lengthBeats: 0.5 },
      { offsetBeats: 6, notes: "F#6", lengthBeats: 0.5 },
      { offsetBeats: 6.5, notes: "E6", lengthBeats: 0.5 },
      { offsetBeats: 7, notes: "D6", lengthBeats: 0.5 },
      { offsetBeats: 7.5, notes: "B5", lengthBeats: 0.5 },
      { offsetBeats: 8, notes: "E5", lengthBeats: 0.5 },
      { offsetBeats: 8.5, notes: "G5", lengthBeats: 0.5 },
      { offsetBeats: 9, notes: "B5", lengthBeats: 0.5 },
      { offsetBeats: 9.5, notes: "E6", lengthBeats: 0.5 },
      { offsetBeats: 10, notes: "D6", lengthBeats: 0.5 },
      { offsetBeats: 10.5, notes: "C6", lengthBeats: 0.5 },
      { offsetBeats: 11, notes: "B5", lengthBeats: 0.5 },
      { offsetBeats: 11.5, notes: "G5", lengthBeats: 0.5 },
      { offsetBeats: 12, notes: "F5", lengthBeats: 0.5 },
      { offsetBeats: 12.5, notes: "A5", lengthBeats: 0.5 },
      { offsetBeats: 13, notes: "C6", lengthBeats: 0.5 },
      { offsetBeats: 13.5, notes: "F6", lengthBeats: 0.5 },
      { offsetBeats: 14, notes: "E6", lengthBeats: 0.5 },
      { offsetBeats: 14.5, notes: "D6", lengthBeats: 0.5 },
      { offsetBeats: 15, notes: "C6", lengthBeats: 0.5 },
      { offsetBeats: 15.5, notes: "A5", lengthBeats: 0.5 },
    ];
    const STAGE2_BASS_ENTRIES = [
      { offsetBeats: 0, notes: "D2", lengthBeats: 2 },
      { offsetBeats: 2, notes: "A2", lengthBeats: 2 },
      { offsetBeats: 4, notes: "G2", lengthBeats: 2 },
      { offsetBeats: 6, notes: "D3", lengthBeats: 2 },
      { offsetBeats: 8, notes: "C3", lengthBeats: 2 },
      { offsetBeats: 10, notes: "G3", lengthBeats: 2 },
      { offsetBeats: 12, notes: "F3", lengthBeats: 2 },
      { offsetBeats: 14, notes: "C4", lengthBeats: 2 },
    ];
    const STAGE2_PAD_ENTRIES = [
      { offsetBeats: 0, notes: "D5 F#5 A5", lengthBeats: 8, gain: 0.9 },
      { offsetBeats: 8, notes: "E5 G5 B5", lengthBeats: 8, gain: 0.9 },
    ];
    const STAGE2_ARP_ENTRIES = [
      { offsetBeats: 0.5, notes: "D6", lengthBeats: 0.3 },
      { offsetBeats: 1, notes: "F#6", lengthBeats: 0.3 },
      { offsetBeats: 1.5, notes: "A6", lengthBeats: 0.3 },
      { offsetBeats: 2, notes: "D7", lengthBeats: 0.3 },
      { offsetBeats: 4.5, notes: "G6", lengthBeats: 0.3 },
      { offsetBeats: 5, notes: "B6", lengthBeats: 0.3 },
      { offsetBeats: 5.5, notes: "D7", lengthBeats: 0.3 },
      { offsetBeats: 6, notes: "G7", lengthBeats: 0.3 },
      { offsetBeats: 8.5, notes: "E6", lengthBeats: 0.3 },
      { offsetBeats: 9, notes: "G6", lengthBeats: 0.3 },
      { offsetBeats: 9.5, notes: "B6", lengthBeats: 0.3 },
      { offsetBeats: 10, notes: "E7", lengthBeats: 0.3 },
      { offsetBeats: 12.5, notes: "F6", lengthBeats: 0.3 },
      { offsetBeats: 13, notes: "A6", lengthBeats: 0.3 },
      { offsetBeats: 13.5, notes: "C7", lengthBeats: 0.3 },
      { offsetBeats: 14, notes: "F7", lengthBeats: 0.3 },
    ];
    const STAGE2_DRUM_PATTERN = "K--hH--h|S--hH--h|K--hH--h|S--hH--h|K--hH--h|S--hH--h|K--hH--h|S--hH-C";

    // ボス戦 - 重低音サウンド
    const STAGE3_BEAT = 0.5;
    const STAGE3_BLOCK_BEATS = 8;
    const STAGE3_CHORD_ENTRIES = [
      { offsetBeats: 0, notes: "C2 E2 G2 C3", lengthBeats: 2 },
      { offsetBeats: 2, notes: "F2 Ab2 C3 F3", lengthBeats: 2 },
      { offsetBeats: 4, notes: "G2 B2 D3 G3", lengthBeats: 2 },
      { offsetBeats: 6, notes: "C3 Eb3 G3 C4", lengthBeats: 2 },
    ];
    const STAGE3_BASS_ENTRIES = [
      { offsetBeats: 0, notes: "C1", lengthBeats: 2, gain: 1.2 },
      { offsetBeats: 2, notes: "F1", lengthBeats: 2, gain: 1.2 },
      { offsetBeats: 4, notes: "G1", lengthBeats: 2, gain: 1.2 },
      { offsetBeats: 6, notes: "C2", lengthBeats: 2, gain: 1.2 },
    ];
    const STAGE3_LEAD_ENTRIES = [
      { offsetBeats: 0, notes: "G4", lengthBeats: 0.25 },
      { offsetBeats: 0.25, notes: "Bb4", lengthBeats: 0.25 },
      { offsetBeats: 0.5, notes: "C5", lengthBeats: 0.25 },
      { offsetBeats: 0.75, notes: "D5", lengthBeats: 0.25 },
      { offsetBeats: 1, notes: "Eb5", lengthBeats: 0.25 },
      { offsetBeats: 1.25, notes: "F5", lengthBeats: 0.25 },
      { offsetBeats: 1.5, notes: "G5", lengthBeats: 0.25 },
      { offsetBeats: 1.75, notes: "Bb5", lengthBeats: 0.25 },
      { offsetBeats: 2, notes: "C6", lengthBeats: 0.5 },
      { offsetBeats: 2.5, notes: "Bb5", lengthBeats: 0.25 },
      { offsetBeats: 2.75, notes: "G5", lengthBeats: 0.25 },
      { offsetBeats: 3, notes: "F5", lengthBeats: 0.25 },
      { offsetBeats: 3.25, notes: "Eb5", lengthBeats: 0.25 },
      { offsetBeats: 3.5, notes: "D5", lengthBeats: 0.5 },
      { offsetBeats: 4, notes: "G5", lengthBeats: 0.25 },
      { offsetBeats: 4.25, notes: "Bb5", lengthBeats: 0.25 },
      { offsetBeats: 4.5, notes: "C6", lengthBeats: 0.25 },
      { offsetBeats: 4.75, notes: "D6", lengthBeats: 0.25 },
      { offsetBeats: 5, notes: "Eb6", lengthBeats: 0.25 },
      { offsetBeats: 5.25, notes: "F6", lengthBeats: 0.25 },
      { offsetBeats: 5.5, notes: "G6", lengthBeats: 0.25 },
      { offsetBeats: 5.75, notes: "Bb6", lengthBeats: 0.25 },
      { offsetBeats: 6, notes: "C7", lengthBeats: 0.5 },
      { offsetBeats: 6.5, notes: "Bb6", lengthBeats: 0.25 },
      { offsetBeats: 6.75, notes: "G6", lengthBeats: 0.25 },
      { offsetBeats: 7, notes: "F6", lengthBeats: 0.25 },
      { offsetBeats: 7.25, notes: "Eb6", lengthBeats: 0.25 },
      { offsetBeats: 7.5, notes: "D6", lengthBeats: 0.25 },
      { offsetBeats: 7.75, notes: "Bb5", lengthBeats: 0.25 },
    ];
    const STAGE3_DRUM_PATTERN = "KS|KS|KS|KS|KS|KS|KS|KS";

    // クリアジングル - 明るい勝利のファンファーレ
    const CLEAR_JINGLE_BEAT = 0.4;
    const CLEAR_JINGLE_NOTES = [
      { offsetBeats: 0, notes: "C5 E5 G5 C6", lengthBeats: 1 },
      { offsetBeats: 1, notes: "E5 G5 B5 E6", lengthBeats: 1 },
      { offsetBeats: 2, notes: "G5 B5 D6 G6", lengthBeats: 1 },
      { offsetBeats: 3, notes: "C6 E6 G6 C7", lengthBeats: 2 },
    ];

    function playStage0Jingle() {
      // ハンガー発進シーケンス専用のFM+PSGジングル
      stopStageMusicInternal();
      const base = context.currentTime;
      const chordDur = 0.9;
      const chordSeq = [
        { t: 0.0, notes: [220.0, 277.18] },
        { t: 0.9, notes: [196.0, 246.94] },
        { t: 1.8, notes: [233.08, 293.66] },
        { t: 2.7, notes: [261.63, 329.63] },
        { t: 3.6, notes: [349.23, 440.0] },
      ];
      for (const chord of chordSeq) {
        for (const freq of chord.notes) {
          scheduleFmVoice(base + chord.t, freq, chordDur, 1.0, fmPreset);
        }
      }

      const leadSeq = [
        { t: 0.45, freq: 440.0, len: 0.5 },
        { t: 1.05, freq: 493.88, len: 0.45 },
        { t: 1.65, freq: 523.25, len: 0.5 },
        { t: 2.25, freq: 587.33, len: 0.48 },
        { t: 2.85, freq: 659.25, len: 0.56 },
        { t: 3.45, freq: 698.46, len: 0.8 },
      ];
      for (const note of leadSeq) {
        scheduleFmVoice(base + note.t, note.freq, note.len, 0.85, fmLead);
      }

      const arpSeq = [
        { t: 0.0, freq: 880.0 },
        { t: 0.3, freq: 660.0 },
        { t: 0.6, freq: 990.0 },
        { t: 0.9, freq: 740.0 },
        { t: 1.2, freq: 1110.0 },
        { t: 1.5, freq: 880.0 },
        { t: 1.8, freq: 1320.0 },
        { t: 2.1, freq: 990.0 },
        { t: 2.4, freq: 1480.0 },
        { t: 2.7, freq: 1110.0 },
        { t: 3.0, freq: 1760.0 },
        { t: 3.3, freq: 1320.0 },
      ];
      for (const tone of arpSeq) {
        schedulePsgTone(base + tone.t, tone.freq, 0.22, psgLevels.arp);
      }

      const hitSeq = [0.1, 0.6, 1.1, 1.6, 2.4, 3.2, 4.0];
      for (const t of hitSeq) {
        schedulePsgNoise(base + t, 0.12, psgLevels.hit);
      }

      schedulePsgTone(base + 4.4, 523.25, 0.9, psgLevels.chord);
      scheduleFmVoice(base + 4.4, 261.63, 1.1, 0.95, fmPreset);
      scheduleFmVoice(base + 4.4, 329.63, 1.1, 0.95, fmPreset);

      return { length: 5.5 };
    }

    function playStage1Theme() {
      // ステージ1用のFinal Takeoff風ハイテンションBGMを構築
      stopStageMusicInternal();
      musicMode = "stage1";
      const start = context.currentTime + 0.12;
      scheduleStage1Block(start);
    }

    function scheduleStage1Block(baseTime) {
      if (musicMode !== "stage1") return;
      const beat = STAGE1_BEAT; // 約133BPM相当の明るい4/4ビート
      const blockLength = beat * STAGE1_BLOCK_BEATS;

      renderScore(STAGE1_CHORD_ENTRIES, beat, baseTime, {
        defaultGain: 0.48,
        preset: fmPreset,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE1_LEAD_ENTRIES, beat, baseTime, {
        defaultGain: 1.05,
        preset: fmLead,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE1_BASS_ENTRIES, beat, baseTime, {
        defaultGain: 0.9,
        preset: fmPreset,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE1_ARP_ENTRIES, beat, baseTime, {
        defaultGain: psgLevels.arp * 0.6,
        preset: null,
        schedule: ({ startTime, duration, frequency, gain }) => {
          schedulePsgTone(startTime, frequency, duration, gain);
        },
      });

      renderEnhancedDrumPattern(STAGE1_DRUM_PATTERN, beat, baseTime, {
        stepsPerBeat: 2,
        velocity: 0.8,
      });
      schedulePsgNoise(baseTime + blockLength - 0.06, 0.08, psgLevels.hit * 0.32);

      const lookAhead = 0.35;
      const nextBase = baseTime + blockLength;
      scheduleMusicTimer(() => scheduleStage1Block(nextBase), Math.max(0, (nextBase - context.currentTime - lookAhead) * 1000));
    }

    function playCityExitFanfare() {
      // シティ脱出時の明るいファンファーレを演奏
      stopStageMusicInternal();
      musicMode = "fanfare";
      const beat = 0.36;
      const base = context.currentTime + 0.08;
      const brassSeq = [
        { t: 0 * beat, notes: [523.25, 659.25, 783.99] },
        { t: 1 * beat, notes: [587.33, 739.99, 880.0] },
        { t: 2 * beat, notes: [659.25, 830.61, 987.77] },
        { t: 3 * beat, notes: [698.46, 880.0, 1046.5] },
        { t: 4 * beat, notes: [783.99, 987.77, 1174.66] },
        { t: 5 * beat, notes: [880.0, 1108.73, 1318.51] },
        { t: 6 * beat, notes: [987.77, 1244.51, 1480.0] },
        { t: 7 * beat, notes: [1046.5, 1318.51, 1661.22] },
      ];
      const sustain = beat * 1.4;
      for (const chord of brassSeq) {
        for (const freq of chord.notes) {
          scheduleFmVoice(base + chord.t, freq, sustain, 1.0, fmPreset);
        }
      }
      const fanfareLead = [
        { t: 0.5 * beat, freq: 1174.66, len: beat * 0.6 },
        { t: 1.5 * beat, freq: 1318.51, len: beat * 0.6 },
        { t: 2.5 * beat, freq: 1480.0, len: beat * 0.6 },
        { t: 3.5 * beat, freq: 1661.22, len: beat * 0.6 },
        { t: 4.5 * beat, freq: 1760.0, len: beat * 0.6 },
        { t: 5.0 * beat, freq: 1864.66, len: beat * 0.5 },
        { t: 5.5 * beat, freq: 2093.0, len: beat * 0.6 },
        { t: 6.5 * beat, freq: 2349.32, len: beat * 0.9 },
      ];
      for (const note of fanfareLead) {
        scheduleFmVoice(base + note.t, note.freq, note.len, 0.95, fmLead);
      }
      for (let i = 0; i < 10; i++) {
        const t = base + i * beat * 0.5;
        schedulePsgNoise(t, 0.08, psgLevels.hit * 0.75);
      }
      const arpFreqs = [1046.5, 1318.51, 1661.22, 2093.0];
      arpFreqs.forEach((freq, idx) => {
        schedulePsgTone(base + idx * beat * 0.6 + 0.1, freq, 0.18, psgLevels.arp * 1.3);
      });
      scheduleMusicTimer(() => {
        if (musicMode === "fanfare") {
          musicMode = null;
        }
      }, Math.max(0, (base + beat * 9 - context.currentTime) * 1000));
    }

    function playStage2Theme() {
      // 宇宙ステージのスペースオペラ風テーマを開始
      stopStageMusicInternal();
      musicMode = "stage2";
      const start = context.currentTime + 0.2;
      scheduleStage2Block(start);
    }

    function playStage3BossTheme() {
      // ボス戦用の重低音テーマを開始
      stopStageMusicInternal();
      musicMode = "stage3";
      const start = context.currentTime + 0.15;
      scheduleStage3Block(start);
    }

    function scheduleStage3Block(baseTime) {
      if (musicMode !== "stage3") return;
      const beat = STAGE3_BEAT;
      const blockLength = beat * STAGE3_BLOCK_BEATS;

      renderScore(STAGE3_CHORD_ENTRIES, beat, baseTime, {
        defaultGain: 1.1,
        preset: fmPreset,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE3_BASS_ENTRIES, beat, baseTime, {
        defaultGain: 1.3,
        preset: fmPreset,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE3_LEAD_ENTRIES, beat, baseTime, {
        defaultGain: 0.9,
        preset: fmLead,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderEnhancedDrumPattern(STAGE3_DRUM_PATTERN, beat, baseTime, {
        stepsPerBeat: 2,
        velocity: 1.0,
      });

      const lookAhead = 0.6;
      const nextBase = baseTime + blockLength;
      scheduleMusicTimer(() => scheduleStage3Block(nextBase), Math.max(0, (nextBase - context.currentTime - lookAhead) * 1000));
    }

    function playStage3Theme() {
      // ボス戦の重低音テーマを開始
      stopStageMusicInternal();
      musicMode = "stage3";
      const start = context.currentTime + 0.15;
      scheduleStage3Block(start);
    }

    function playClearJingle() {
      // クリア時の明るいファンファーレ
      stopStageMusicInternal();
      musicMode = "clear";
      const start = context.currentTime + 0.1;
      
      CLEAR_JINGLE_NOTES.forEach(entry => {
        const startTime = start + entry.offsetBeats * CLEAR_JINGLE_BEAT;
        const duration = entry.lengthBeats * CLEAR_JINGLE_BEAT;
        const notes = entry.notes.split(/\s+/).filter(Boolean);
        
        notes.forEach(note => {
          const frequency = noteNameToFrequency(note);
          if (frequency) {
            scheduleFmVoice(startTime, frequency, duration, 1.2, fmLead);
          }
        });
      });
    }

    function scheduleStage2Block(baseTime) {
      if (musicMode !== "stage2") return;
      const beat = STAGE2_BEAT; // ゆったりとしたスペースオペラテンポ
      const blockLength = beat * STAGE2_BLOCK_BEATS;

      renderScore(STAGE2_CHORD_ENTRIES, beat, baseTime, {
        defaultGain: 0.92,
        preset: fmPreset,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE2_LEAD_ENTRIES, beat, baseTime, {
        defaultGain: 1.0,
        preset: fmLead,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE2_BASS_ENTRIES, beat, baseTime, {
        defaultGain: 1.1,
        preset: fmPreset,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderScore(STAGE2_PAD_ENTRIES, beat, baseTime, {
        defaultGain: 0.7,
        preset: fmLead,
        schedule: ({ startTime, duration, frequency, gain, preset }) => {
          scheduleFmVoice(startTime, frequency, duration, gain, preset);
        },
      });

      renderEnhancedDrumPattern(STAGE2_DRUM_PATTERN, beat, baseTime, {
        stepsPerBeat: 2,
        velocity: 0.9,
      });

      renderScore(STAGE2_ARP_ENTRIES, beat, baseTime, {
        defaultGain: psgLevels.arp * 1.05,
        preset: null,
        schedule: ({ startTime, duration, frequency, gain }) => {
          schedulePsgTone(startTime, frequency, duration, gain);
        },
      });

      const lookAhead = 0.6;
      const nextBase = baseTime + blockLength;
      scheduleMusicTimer(() => scheduleStage2Block(nextBase), Math.max(0, (nextBase - context.currentTime - lookAhead) * 1000));
    }

    function playLaserSfx(kind = "player") {
      // レーザー発射音を簡易FM/PSGで再現しつつアタック感を強調
      const now = context.currentTime + 0.002;
      const osc = context.createOscillator();
      osc.type = "sawtooth";
      const base = kind === "enemy" ? 520 : 760;
      osc.frequency.setValueAtTime(base, now);
      osc.frequency.exponentialRampToValueAtTime(base * (kind === "enemy" ? 0.58 : 1.28), now + 0.18);
      const burst = context.createOscillator();
      burst.type = "square";
      burst.frequency.setValueAtTime(base * 2.2, now);
      burst.frequency.exponentialRampToValueAtTime(base * 1.1, now + 0.12);
      const filter = context.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.setValueAtTime(kind === "enemy" ? 380 : 620, now);
      const gain = context.createGain();
      const peak = kind === "enemy" ? 0.32 : 0.4;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(peak, now + 0.012);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);
      osc.connect(filter);
      burst.connect(filter);
      filter.connect(gain);
      gain.connect(sfxBus);
      osc.start(now);
      osc.stop(now + 0.26);
      burst.start(now);
      burst.stop(now + 0.18);
      track(osc);
      track(burst);
      track(filter);
      track(gain);
    }

    function playExplosionSfx(intensity = 1) {
      // 爆発時のノイズバーストを生成
      const now = context.currentTime + 0.002;
      const source = context.createBufferSource();
      source.buffer = noiseBuffer;
      source.loop = false;
      source.playbackRate.setValueAtTime(1.0 - Math.min(0.35, intensity * 0.12) + Math.random() * 0.08, now);
      const filter = context.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.setValueAtTime(320 + intensity * 220, now);
      filter.Q.setValueAtTime(0.8, now);
      const gain = context.createGain();
      const peak = Math.min(1.08, 0.36 + intensity * 0.32);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(peak, now + 0.016);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.82 + intensity * 0.32);
      const thump = context.createOscillator();
      thump.type = "sine";
      thump.frequency.setValueAtTime(90 + intensity * 40, now);
      thump.frequency.exponentialRampToValueAtTime(48, now + 0.32);
      const thumpGain = context.createGain();
      thumpGain.gain.setValueAtTime(0.0001, now);
      thumpGain.gain.linearRampToValueAtTime(Math.min(0.78, 0.3 + intensity * 0.28), now + 0.035);
      thumpGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      source.connect(filter);
      filter.connect(gain);
      gain.connect(sfxBus);
      thump.connect(thumpGain);
      thumpGain.connect(sfxBus);
      source.start(now);
      source.stop(now + 0.8 + intensity * 0.2);
      thump.start(now);
      thump.stop(now + 0.5);
      track(source);
      track(filter);
      track(gain);
      track(thump);
      track(thumpGain);
    }

    function playShieldFixSfx() {
      // シールド補給時の明るいチャイムを生成
      const now = context.currentTime + 0.002;
      const chime = context.createOscillator();
      chime.type = "triangle";
      chime.frequency.setValueAtTime(880, now);
      chime.frequency.exponentialRampToValueAtTime(1480, now + 0.22);
      const chimeGain = context.createGain();
      chimeGain.gain.setValueAtTime(0.0001, now);
      chimeGain.gain.linearRampToValueAtTime(0.52, now + 0.028);
      chimeGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);

      const sparkle = context.createBufferSource();
      sparkle.buffer = noiseBuffer;
      sparkle.loop = false;
      sparkle.playbackRate.setValueAtTime(2.8, now);
      const sparkleFilter = context.createBiquadFilter();
      sparkleFilter.type = "bandpass";
      sparkleFilter.frequency.setValueAtTime(2600, now);
      sparkleFilter.Q.setValueAtTime(8.0, now);
      const sparkleGain = context.createGain();
      sparkleGain.gain.setValueAtTime(0.0001, now);
      sparkleGain.gain.linearRampToValueAtTime(0.28, now + 0.04);
      sparkleGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.42);

      const ping = context.createOscillator();
      ping.type = "sine";
      ping.frequency.setValueAtTime(1320, now);
      ping.frequency.exponentialRampToValueAtTime(1980, now + 0.12);
      const pingGain = context.createGain();
      pingGain.gain.setValueAtTime(0.0001, now);
      pingGain.gain.linearRampToValueAtTime(0.34, now + 0.02);
      pingGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.36);

      chime.connect(chimeGain);
      chimeGain.connect(sfxBus);
      sparkle.connect(sparkleFilter);
      sparkleFilter.connect(sparkleGain);
      sparkleGain.connect(sfxBus);
      ping.connect(pingGain);
      pingGain.connect(sfxBus);

      chime.start(now);
      chime.stop(now + 0.7);
      sparkle.start(now);
      sparkle.stop(now + 0.45);
      ping.start(now);
      ping.stop(now + 0.4);

      track(chime);
      track(chimeGain);
      track(sparkle);
      track(sparkleFilter);
      track(sparkleGain);
      track(ping);
      track(pingGain);
    }

    function playSpaceAscentSfx(progress) {
      // 宇宙上昇時の効果音
      const now = context.currentTime + 0.002;
      
      // 上昇感のあるサーチェントノイズ
      const noiseSource = context.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.loop = true;
      noiseSource.playbackRate.setValueAtTime(2.5 + progress * 3.5, now);
      
      const noiseFilter = context.createBiquadFilter();
      noiseFilter.type = "highpass";
      noiseFilter.frequency.setValueAtTime(800 + progress * 1200, now);
      noiseFilter.Q.setValueAtTime(2.0, now);
      
      const noiseGain = context.createGain();
      noiseGain.gain.setValueAtTime(0.0001, now);
      noiseGain.gain.linearRampToValueAtTime(0.15 + progress * 0.25, now + 0.1);
      noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 1.5);
      
      // 上昇するトーン
      const osc = context.createOscillator();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(120, now);
      osc.frequency.exponentialRampToValueAtTime(480 + progress * 720, now + 1.2);
      
      const oscFilter = context.createBiquadFilter();
      oscFilter.type = "lowpass";
      oscFilter.frequency.setValueAtTime(800, now);
      oscFilter.frequency.linearRampToValueAtTime(2000 + progress * 1000, now + 1.0);
      
      const oscGain = context.createGain();
      oscGain.gain.setValueAtTime(0.0001, now);
      oscGain.gain.linearRampToValueAtTime(0.08 + progress * 0.12, now + 0.2);
      oscGain.gain.exponentialRampToValueAtTime(0.0001, now + 1.8);
      
      // 接続
      noiseSource.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(sfxBus);
      
      osc.connect(oscFilter);
      oscFilter.connect(oscGain);
      oscGain.connect(sfxBus);
      
      // 再生
      noiseSource.start(now);
      noiseSource.stop(now + 1.5);
      osc.start(now);
      osc.stop(now + 1.8);
      
      track(noiseSource);
      track(noiseFilter);
      track(noiseGain);
      track(osc);
      track(oscFilter);
      track(oscGain);
    }

    return {
      context,
      playStage0Jingle,
      playStage1Theme,
      playStage2Theme,
      playStage3Theme,
      playCityExitFanfare,
      playClearJingle,
      stopStageMusic: stopStageMusicInternal,
      playLaserSfx,
      playExplosionSfx,
      playSpaceAscentSfx,
      playShieldFixSfx,
    };
  }

  // === サウンドテストモード ===
  let currentMode = "game"; // "game" or "soundTest"
  let currentTrack = null;
  let soundTestTimer = null;

  function initSoundTestMode() {
    const gameModeBtn = document.getElementById("gameMode");
    const finalBossModeBtn = document.getElementById("finalBossMode");
    const soundModeBtn = document.getElementById("soundModeBtn");
    const soundTestPanel = document.getElementById("soundTest");
    const trackButtons = document.querySelectorAll(".track-btn");

    // モード切り替え
    gameModeBtn.addEventListener("click", () => {
      setGameMode("game");
    });
    finalBossModeBtn.addEventListener("click", () => {
      setGameMode("finalBossTest");
    });

    soundModeBtn.addEventListener("click", () => {
      setGameMode("soundTest");
    });

    // トラック選択
    trackButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        const track = btn.dataset.track;
        playSoundTestTrack(track);
        
        // ボタンの状態更新
        trackButtons.forEach(b => b.classList.remove("playing"));
        btn.classList.add("playing");
      });
    });
  }

  function setGameMode(mode) {
    currentMode = mode;
    const gameModeBtn = document.getElementById("gameMode");
    const finalBossModeBtn = document.getElementById("finalBossMode");
    const soundModeBtn = document.getElementById("soundModeBtn");
    const soundTestPanel = document.getElementById("soundTest");
    const hudLabel = document.getElementById("hud");

    if (mode === "soundTest") {
      gameModeBtn.classList.remove("active");
      finalBossModeBtn.classList.remove("active");
      soundModeBtn.classList.add("active");
      soundTestPanel.style.display = "flex";
      hudLabel.textContent = "SOUND TEST MODE";
      
      // ゲームを一時停止
      stopStageMusic();
      gamePhase = "soundTest";
      
    } else if (mode === "finalBossTest") {
      gameModeBtn.classList.remove("active");
      soundModeBtn.classList.remove("active");
      finalBossModeBtn.classList.add("active");
      soundTestPanel.style.display = "none";
      hudLabel.textContent = "FINAL BOSS TEST MODE";

      // 最終ボス試遊用に即座にステージを構築
      stopSoundTestTrack();
      startFinalBossTest();

    } else {
      soundModeBtn.classList.remove("active");
      gameModeBtn.classList.add("active");
       finalBossModeBtn.classList.remove("active");
      soundTestPanel.style.display = "none";
      hudLabel.textContent = "CITY RUN / WIREFRAME MODE";
      
      // トラック再生を停止
      stopSoundTestTrack();
      
      // ゲームをリセット
      resetGame();
    }
  }

  function playSoundTestTrack(track) {
    stopSoundTestTrack();
    currentTrack = track;
    
    const controller = ensureAudioController();
    if (!controller) return;
    
    switch(track) {
      case "stage0":
        controller.playStage0Jingle();
        break;
      case "stage1":
        controller.playStage1Theme();
        break;
      case "stage2":
        controller.playStage2Theme();
        break;
      case "stage3":
        controller.playStage3Theme();
        break;
      case "clear":
        controller.playClearJingle();
        break;
      case "ascent":
        controller.playSpaceAscentSfx(0.5);
        break;
    }
  }

  function playBossThemeTest() {
    // ボス戦テーマ用のテスト再生関数
    const controller = ensureAudioController();
    if (!controller) return;
    
    stopStageMusic();
    musicMode = "stage3";
    
    // 少し待ってから再生を開始（音声コンテキストの準備を待つ）
    setTimeout(() => {
      if (currentMode === "soundTest" && currentTrack === "stage3") {
        const start = controller.context.currentTime + 0.12;
        scheduleStage3Block(start);
      }
    }, 100);
  }

  function stopSoundTestTrack() {
    if (soundTestTimer) {
      clearTimeout(soundTestTimer);
      soundTestTimer = null;
    }
    stopStageMusic();
    currentTrack = null;
    
    // ボタンの状態をリセット
    document.querySelectorAll(".track-btn").forEach(btn => {
      btn.classList.remove("playing");
    });
  }

  // === ベクトル演算ユーティリティ ===
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // === イージング関数 ===
  const easeInOutCubic = (t) => (t <= 0 ? 0 : t >= 1 ? 1 : t < 0.5
    ? 4 * t * t * t
    : 1 - Math.pow(-2 * t + 2, 3) * 0.5);
  const easeOutCubic = (t) => (t <= 0 ? 0 : 1 - Math.pow(1 - clamp(t, 0, 1), 3));
  const smoothstep = (t) => {
    const k = clamp(t, 0, 1);
    return k * k * (3 - 2 * k);
  };

  // === 自機ステート ===
  const player = {
    pos: { x: 0, y: 10, z: 40 }, // 後方から自機を見るためZを正にスタート
    vel: { x: 0, y: 0 },
    speedForward: 80,   // 高速感を保ちつつステージを長く感じさせるため速度を抑制
    roll: 0,
    maxHp: 120,
    hp: 120,
    maxShield: 60,
    shield: 60,
    maxStocks: 3,
    stocks: 3,
    invuln: 0,
    hitRadius: 6,
    visible: true, // ゲームオーバー時に自機を非表示にするためのフラグ
  };

  const camera = {
    pos: { x: 0, y: 18, z: 80 },
    targetOffset: { x: 0, y: -4, z: -40 },
    shake: 0,
  };

  // === シーンジオメトリ格納 ===
  const cityObjects = [];
  // === 敵オブジェクト格納 ===
  const enemyObjects = [];
  let simTime = 0; // シミュレーション経過時間（敵挙動の位相計算用）
  // === 投射物（プレイヤー・ミサイル・敵ショット）格納 ===
  const playerShots = [];
  const playerMissiles = [];
  const enemyShots = [];
  const explosions = [];
  const shieldPickups = [];
  const shieldFixBanner = {
    active: false,
    time: 0,
    duration: 1.4,
    colorPhase: 0,
    text: "SHIELD FIX",
  };
  let shotCooldown = 0;
  let missileCooldown = 0;
  const MISSILE_STOCK_MAX = Infinity; // ミサイルを無制限に扱うための疑似上限値
  const MAX_CONCURRENT_PLAYER_MISSILES = 4; // 同時発射可能な自機ミサイル数の上限
  const MISSILE_FIRE_INTERVAL = 0.4; // 連射間隔を短縮して同時発射を支援
  let missilesRemaining = MISSILE_STOCK_MAX;
  let missileRequest = false;
  const boss = {
    active: false,
    destroyed: false,
    spawnTriggerZ: -2400,
    pos: { x: 0, y: 4, z: -3200 },
    hp: 1200,
    maxHp: 1200,
    fireCooldown: 0,
    fireInterval: 1.1,
    shake: 0,
    edges: null,
    hitboxes: [],
    turretYaw: 0,
    type: "boss",
    variant: "tank",
    waveCharge: 0,
    suctionActive: false,
    suctionTimer: 0,
    suctionDuration: 0,
    suctionCooldown: 0,
    suctionWarmup: 0,
    suctionProgress: 0,
    restZ: -3200,
    chargeActive: false,
    chargeTimer: 0,
    chargeDuration: 0,
    chargeCooldown: 0,
    chargeOriginZ: 0,
    chargeTargetZ: 0,
    chargeProgress: 0,
    chargeLaughed: false,
    laughTimer: 0,
    laughCooldown: 0,
    waveCooldown: 0,
    eyeLaserCooldown: 0,
  };
  // === AIパネル用の共有テレメトリ ===
  const nearestEnemy = { typeId: "NONE", distance: 0 };
  const currentStage = { code: "HG" };
  const currentEvent = { code: 0 };
  let aiPanelTimer = null;
  let stageClear = false;
  let stageClearTime = 0;
  let gameOver = false;
  let gameOverTime = 0;
  let finalBossQueued = false;
  let finalBossCountdown = 0;

  // === ゲームフェーズ管理 ===
  let gamePhase = "stage0";
  let phaseTime = 0;
  const stage0State = {
    startZ: 180,
    targetZ: 42,
    startY: 12,
    targetY: 10,
    doorProgress: 0,
    launchProgress: 0,
    thruster: 0,
  };
  const hangarScene = createHangarScene();
  const stage1Events = {
    chaseSpawned: false,
  };
  const bossDistanceConstraint = {
    min: 380, // 自機とボスの最短距離（近接しすぎ防止）
    max: 520, // 自機弾が届く範囲を維持しつつ遠景シルエットを演出
  };
  const battleshipDistanceConstraint = {
    min: 540, // 戦艦の波動砲を視認しつつ被弾圏外に保つ距離
    max: 780,
  };
  const finalBossDistanceConstraint = {
    min: 520, // 最終ボスとの距離を張り詰めた間合いに保つ
    max: 700,
  };
  const finalBossChargeConstraint = {
    min: 160, // 突進時に画面手前へ迫らせる下限距離
    max: 640,
  };
  let stage1Clear = false;
  const cityExitState = {
    progress: 0,
    duration: 9.0,
    passed: false,
    ascentSfxPlayed: false,
    streaks: [],
  };
  const spaceScene = {
    objects: [],
    rings: [],
    stars: [],
    walkers: [],
    corridors: [],
    guideBeacons: [],
    guidePhase: 0,
    waveTimer: 0,
    waveInterval: 9.5,
  };
  let environment = "city";
  let skyMix = 0;

  // === ワイヤーフレームラインを投影して描画 ===
  function projectPointXYZ(px, py, pz) {
    const dx = px - camera.pos.x;
    const dy = py - camera.pos.y;
    const dz = pz - camera.pos.z;
    const z = -dz; // カメラ前方が-Zなので符号反転
    if (z < display.zNear || z > display.zFar) {
      return null;
    }
    const scale = display.fov / z;
    const halfHeight = canvas.height * 0.5;
    return {
      x: canvas.width * 0.5 + dx * scale * halfHeight,
      y: canvas.height * 0.5 - dy * scale * halfHeight,
      z,
    };
  }

  function projectPoint(ptOrX, y, z) {
    if (typeof ptOrX === "number") {
      return projectPointXYZ(ptOrX, y, z);
    }
    return projectPointXYZ(ptOrX.x, ptOrX.y, ptOrX.z);
  }

  // === ワイヤーフレームライン描画 ===
  function drawEdges(edges, color, width, glow, transform) {
    // transform指定時は平行移動＋ヨー回転をワンパス適用してGC削減
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.shadowColor = glow || color;
    ctx.shadowBlur = glow ? 18 : 0;
    ctx.beginPath();
    const hasTransform = Boolean(transform);
    const tx = hasTransform ? (transform.tx ?? transform.x ?? 0) : 0;
    const ty = hasTransform ? (transform.ty ?? transform.y ?? 0) : 0;
    const tz = hasTransform ? (transform.tz ?? transform.z ?? 0) : 0;
    const yaw = hasTransform ? (transform.yaw ?? 0) : 0;
    const cosYaw = yaw ? Math.cos(yaw) : 1;
    const sinYaw = yaw ? Math.sin(yaw) : 0;
    if (edges instanceof Float32Array) {
      for (let i = 0; i < edges.length; i += 6) {
        let ax = edges[i];
        let ay = edges[i + 1];
        let az = edges[i + 2];
        let bx = edges[i + 3];
        let by = edges[i + 4];
        let bz = edges[i + 5];
        if (yaw) {
          const rxA = ax * cosYaw + az * sinYaw;
          const rzA = -ax * sinYaw + az * cosYaw;
          const rxB = bx * cosYaw + bz * sinYaw;
          const rzB = -bx * sinYaw + bz * cosYaw;
          ax = rxA;
          az = rzA;
          bx = rxB;
          bz = rzB;
        }
        const pa = projectPointXYZ(ax + tx, ay + ty, az + tz);
        const pb = projectPointXYZ(bx + tx, by + ty, bz + tz);
        if (!pa || !pb) continue;
        ctx.moveTo(pa.x, pa.y);
        ctx.lineTo(pb.x, pb.y);
      }
    } else {
      for (let i = 0; i < edges.length; i++) {
        const edge = edges[i];
        let ax = edge[0].x;
        let ay = edge[0].y;
        let az = edge[0].z;
        let bx = edge[1].x;
        let by = edge[1].y;
        let bz = edge[1].z;
        if (yaw) {
          const rxA = ax * cosYaw + az * sinYaw;
          const rzA = -ax * sinYaw + az * cosYaw;
          const rxB = bx * cosYaw + bz * sinYaw;
          const rzB = -bx * sinYaw + bz * cosYaw;
          ax = rxA;
          az = rzA;
          bx = rxB;
          bz = rzB;
        }
        const pa = projectPointXYZ(ax + tx, ay + ty, az + tz);
        const pb = projectPointXYZ(bx + tx, by + ty, bz + tz);
        if (!pa || !pb) continue;
        ctx.moveTo(pa.x, pa.y);
        ctx.lineTo(pb.x, pb.y);
      }
    }
    ctx.stroke();
  }

  // === ステージ0ハンガーの描画 ===
  function drawStage0Hangar() {
    const glowBase = 0.55 + stage0State.launchProgress * 0.25;
    const doorOpen = stage0State.doorProgress;
    drawEdges(hangarScene.frame, `rgba(0, 90, 210, ${glowBase})`, 2.2, `rgba(0, 110, 255, ${glowBase})`);
    drawEdges(hangarScene.sideSupports, "rgba(0, 120, 255, 0.7)", 1.8, "rgba(0, 120, 255, 0.6)");
    drawEdges(hangarScene.ceilingBeams, "rgba(0, 150, 255, 0.75)", 1.6, "rgba(0, 150, 255, 0.6)");
    const floorAlpha = 0.45 + stage0State.thruster * 0.4;
    drawEdges(hangarScene.floorGrid, `rgba(0, 150, 255, ${floorAlpha})`, 1.2, `rgba(0, 120, 255, ${floorAlpha})`);
    const railGlow = 0.6 + stage0State.launchProgress * 0.3;
    drawEdges(hangarScene.walkwayRibs, `rgba(0, 200, 255, ${railGlow})`, 2.0, `rgba(0, 200, 255, ${railGlow})`);
    drawEdges(hangarScene.launchRails, `rgba(0, 255, 240, ${0.6 + stage0State.thruster * 0.5})`, 2.6, "rgba(0, 255, 240, 0.9)");
    const slide = 9 * doorOpen;
    drawEdges(hangarScene.doorLeft, `rgba(0, 180, 255, ${0.8 - doorOpen * 0.15})`, 2.6, "rgba(0, 180, 255, 0.8)", { tx: -slide });
    drawEdges(hangarScene.doorRight, `rgba(0, 180, 255, ${0.8 - doorOpen * 0.15})`, 2.6, "rgba(0, 180, 255, 0.8)", { tx: slide });
    drawEdges(hangarScene.exteriorRing, "rgba(0, 150, 255, 0.65)", 2.0, "rgba(0, 150, 255, 0.6)");
    drawEdges(hangarScene.towerAnchors, "rgba(0, 110, 220, 0.6)", 1.8, "rgba(0, 110, 220, 0.5)");
  }

  function drawStage0Thruster() {
    if (stage0State.thruster <= 0.001) return;
    const strength = stage0State.thruster;
    const tailLength = 10 + strength * 30;
    const base = {
      x: player.pos.x,
      y: player.pos.y,
      z: player.pos.z + 10,
    };
    const tail = {
      x: base.x,
      y: base.y - 1 - strength * 2,
      z: base.z + tailLength,
    };
    const head = projectPoint(base);
    const tip = projectPoint(tail);
    if (!head || !tip) return;
    ctx.save();
    ctx.lineWidth = 1.2 + strength * 6;
    ctx.strokeStyle = `rgba(0, 255, 255, ${0.75 + strength * 0.2})`;
    ctx.shadowColor = `rgba(0, 200, 255, ${0.9})`;
    ctx.shadowBlur = 24 + strength * 16;
    ctx.beginPath();
    ctx.moveTo(head.x, head.y);
    ctx.lineTo(tip.x, tip.y);
    ctx.stroke();
    ctx.restore();
  }

  function drawInvulnAura() {
    if (!player.visible || !rollState.active) return;
    const centerWorld = { x: player.pos.x, y: player.pos.y, z: player.pos.z - 4 };
    const refWorld = { x: player.pos.x + player.hitRadius * 1.2, y: player.pos.y, z: player.pos.z - 4 };
    const center = projectPoint(centerWorld);
    const ref = projectPoint(refWorld);
    if (!center || !ref) return;
    const pixelScale = Math.max(2, Math.hypot(ref.x - center.x, ref.y - center.y));
    const baseRadius = pixelScale * 2.8;
    const rollRatio = clamp(1 - rollState.timer / rollState.duration, 0, 1);
    const auraStrength = 0.35 + rollRatio * 0.85;
    const pulse = 0.92 + Math.sin(performance.now() * 0.008 + player.pos.z * 0.02) * 0.08;
    const radius = baseRadius * (0.9 + auraStrength * 0.3) * pulse;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.shadowColor = `rgba(0, 190, 255, ${0.35 + 0.2 * Math.min(1, auraStrength)})`;
    ctx.shadowBlur = 18 + auraStrength * 26;
    const gradient = ctx.createRadialGradient(center.x, center.y, Math.max(6, radius * 0.35), center.x, center.y, radius);
    gradient.addColorStop(0, `rgba(0, 255, 255, ${0.32 + auraStrength * 0.16})`);
    gradient.addColorStop(0.7, `rgba(0, 150, 255, ${0.18 + auraStrength * 0.18})`);
    gradient.addColorStop(1, "rgba(0, 90, 255, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 1.4 + auraStrength * 2.0;
    ctx.strokeStyle = `rgba(0, 255, 255, ${0.15 + auraStrength * 0.2})`;
    ctx.beginPath();
    ctx.arc(center.x, center.y, radius * 0.65, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  function initCityExitVisuals() {
    // 宇宙突入演出用のストリークと地平線演出を初期化
    cityExitState.streaks.length = 0;
    const streakCount = 26;
    for (let i = 0; i < streakCount; i++) {
      cityExitState.streaks.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height * -0.4,
        length: 80 + Math.random() * 140,
        tilt: (Math.random() - 0.5) * 0.5,
        speed: 160 + Math.random() * 240,
      });
    }
  }

  function updateCityExitStreaks(dt, progress) {
    // 宇宙への上昇感を強めるためストリークを上から下へ高速移動させる
    if (!cityExitState.streaks.length) return;
    const speedScale = 0.35 + progress * 1.1;
    for (const streak of cityExitState.streaks) {
      streak.y += streak.speed * speedScale * dt;
      if (streak.y > canvas.height + streak.length) {
        streak.y = Math.random() * canvas.height * -0.4;
        streak.x = Math.random() * canvas.width;
        streak.length = 80 + Math.random() * 160;
        streak.speed = 160 + Math.random() * 260;
        streak.tilt = (Math.random() - 0.5) * 0.5;
      }
    }
  }

  function drawCityExitBackdrop() {
    // 宇宙突入時に大気圏と地球のカーブを強調して視覚化
    if (gamePhase !== "cityExit") return;
    const progress = cityExitState.progress;
    ctx.save();
    const horizonY = canvas.height * (0.62 - progress * 0.28);
    const atmosphere = ctx.createLinearGradient(0, horizonY, 0, canvas.height);
    atmosphere.addColorStop(0, `rgba(0, 26, 70, ${0.45 + progress * 0.35})`);
    atmosphere.addColorStop(0.45, `rgba(0, 90, 180, ${0.36 + progress * 0.3})`);
    atmosphere.addColorStop(1, `rgba(0, 140, 220, ${0.18 + progress * 0.2})`);
    ctx.fillStyle = atmosphere;
    ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);

    const glow = ctx.createLinearGradient(0, horizonY - 200, 0, horizonY + 80);
    glow.addColorStop(0, "rgba(0, 180, 255, 0)");
    glow.addColorStop(0.6, `rgba(0, 220, 255, ${0.28 + progress * 0.28})`);
    glow.addColorStop(1, "rgba(0, 255, 255, 0)");
    ctx.fillStyle = glow;
    ctx.fillRect(0, horizonY - 200, canvas.width, 280);

    ctx.save();
    const arcRadius = canvas.height * (1.6 - progress * 0.4);
    ctx.translate(canvas.width * 0.5, horizonY + arcRadius * 0.18);
    ctx.scale(1.82, 0.62 + progress * 0.22);
    ctx.lineWidth = 2.4 + progress * 3.6;
    ctx.strokeStyle = `rgba(0, 220, 255, ${0.32 + progress * 0.4})`;
    ctx.shadowColor = `rgba(0, 220, 255, ${0.25 + progress * 0.35})`;
    ctx.shadowBlur = 28 + progress * 60;
    ctx.beginPath();
    ctx.arc(0, 0, arcRadius, Math.PI * 1.06, Math.PI * 1.94, false);
    ctx.stroke();
    ctx.restore();

    if (cityExitState.streaks.length) {
      ctx.globalCompositeOperation = "lighter";
      for (const streak of cityExitState.streaks) {
        const length = streak.length * (0.4 + progress * 0.9);
        ctx.strokeStyle = `rgba(140, 210, 255, ${0.18 + progress * 0.45})`;
        ctx.lineWidth = 1.2 + progress * 2.2;
        ctx.beginPath();
        ctx.moveTo(streak.x, streak.y);
        ctx.lineTo(streak.x + Math.sin(streak.tilt) * length * 0.6, streak.y + length);
        ctx.stroke();
      }
      ctx.globalCompositeOperation = "source-over";
    }
    ctx.restore();
  }

  function drawSpaceAscentEffect() {
    if (gamePhase !== "cityExit") return;
    const t = cityExitState.progress;
    const climbStart = 0.35;
    const climbStrength = smoothstep((t - climbStart) / Math.max(0.0001, 1 - climbStart));
    
    if (climbStrength <= 0.001) return;
    
    // 複数のスラストエフェクトを生成
    const thrustCount = 3;
    for (let i = 0; i < thrustCount; i++) {
      const offset = (i - (thrustCount - 1) / 2) * 2;
      const base = {
        x: player.pos.x + offset,
        y: player.pos.y,
        z: player.pos.z + 8,
      };
      const tailLength = 15 + climbStrength * 40 + i * 5;
      const tail = {
        x: base.x + (Math.random() - 0.5) * 2,
        y: base.y - 2 - climbStrength * 3,
        z: base.z + tailLength,
      };
      
      const head = projectPoint(base);
      const tip = projectPoint(tail);
      if (!head || !tip) continue;
      
      ctx.save();
      const alpha = (0.6 + climbStrength * 0.3) * (1 - i * 0.2);
      const width = 2 + climbStrength * 4 - i * 0.5;
      
      // 青白い宇宙スラスト色
      const gradient = ctx.createLinearGradient(head.x, head.y, tip.x, tip.y);
      gradient.addColorStop(0, `rgba(200, 220, 255, ${alpha})`);
      gradient.addColorStop(0.5, `rgba(150, 200, 255, ${alpha * 0.8})`);
      gradient.addColorStop(1, `rgba(100, 150, 255, ${alpha * 0.3})`);
      
      ctx.lineWidth = width;
      ctx.strokeStyle = gradient;
      ctx.shadowColor = `rgba(150, 200, 255, ${alpha * 0.9})`;
      ctx.shadowBlur = 20 + climbStrength * 30;
      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tip.x, tip.y);
      ctx.stroke();
      ctx.restore();
    }
    
    // 粒子効果
    const particleCount = Math.floor(climbStrength * 8);
    for (let i = 0; i < particleCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = 5 + Math.random() * 15;
      const particle = {
        x: player.pos.x + Math.cos(angle) * distance,
        y: player.pos.y - Math.random() * 10,
        z: player.pos.z + 10 + Math.random() * 20,
      };
      const screen = projectPoint(particle);
      if (!screen) continue;
      
      ctx.save();
      ctx.fillStyle = `rgba(180, 200, 255, ${climbStrength * 0.6})`;
      ctx.shadowColor = `rgba(150, 200, 255, 0.8)`;
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, 1 + Math.random() * 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // === ボックスエッジ生成（都市ビル用） ===
  function createBoxEdges(cx, cy, cz, w, h, d) {
    const x = w * 0.5;
    const y = h * 0.5;
    const z = d * 0.5;
    const pts = [
      { x: cx - x, y: cy - y, z: cz - z },
      { x: cx + x, y: cy - y, z: cz - z },
      { x: cx + x, y: cy + y, z: cz - z },
      { x: cx - x, y: cy + y, z: cz - z },
      { x: cx - x, y: cy - y, z: cz + z },
      { x: cx + x, y: cy - y, z: cz + z },
      { x: cx + x, y: cy + y, z: cz + z },
      { x: cx - x, y: cy + y, z: cz + z },
    ];
    const indices = [
      [0,1],[1,2],[2,3],[3,0],
      [4,5],[5,6],[6,7],[7,4],
      [0,4],[1,5],[2,6],[3,7],
    ];
    return indices.map(([a, b]) => [pts[a], pts[b]]);
  }

  // === ゲート構造生成 ===
  function createGateEdges(cx, cy, cz, w, h, d, thickness) {
    const edges = [];
    const half = thickness * 0.5;
    // フレームは四角形のリング
    const segments = [
      createBoxEdges(cx - (w * 0.5 - half), cy, cz, thickness, h, d),
      createBoxEdges(cx + (w * 0.5 - half), cy, cz, thickness, h, d),
      createBoxEdges(cx, cy + (h * 0.5 - half), cz, w - thickness * 2, thickness, d),
      createBoxEdges(cx, cy - (h * 0.5 - half), cz, w - thickness * 2, thickness, d),
    ];
    for (const seg of segments) edges.push(...seg);
    return edges;
  }

  // === グラウンドグリッド生成 ===
  function createGroundGrid(zStart, zEnd, step, widthSpan) {
    const edges = [];
    for (let z = zStart; z >= zEnd; z -= step) {
      edges.push([
        { x: -widthSpan, y: 0, z },
        { x: widthSpan, y: 0, z },
      ]);
    }
    for (let x = -widthSpan; x <= widthSpan; x += step) {
      edges.push([
        { x, y: 0, z: zStart },
        { x, y: 0, z: zEnd },
      ]);
    }
    return edges;
  }

  // === ステージ0用ハンガー形状生成 ===
  function createHangarScene() {
    const frame = createBoxEdges(0, 13, 150, 42, 28, 74);
    const sideSupports = [];
    for (const side of [-18, 18]) {
      for (let i = 0; i < 4; i++) {
        const z = 184 - i * 18;
        sideSupports.push(...createBoxEdges(side, 13, z, 2.4, 26, 6));
      }
    }
    const ceilingBeams = [];
    for (let i = 0; i <= 3; i++) {
      const z = 184 - i * 18;
      ceilingBeams.push(...createBoxEdges(0, 24, z, 36, 2, 2));
    }
    const floorGrid = [];
    const gridStart = 188;
    const gridEnd = 110;
    for (let z = gridStart; z >= gridEnd; z -= 6) {
      floorGrid.push([
        { x: -16, y: 0, z },
        { x: 16, y: 0, z },
      ]);
    }
    for (let x = -16; x <= 16; x += 4) {
      floorGrid.push([
        { x, y: 0, z: gridStart },
        { x, y: 0, z: gridEnd },
      ]);
    }
    const launchRails = [
      [{ x: -4.5, y: 1.4, z: 188 }, { x: -4.5, y: 1.4, z: 108 }],
      [{ x: 4.5, y: 1.4, z: 188 }, { x: 4.5, y: 1.4, z: 108 }],
      [{ x: -4.5, y: 1.4, z: 108 }, { x: -1.5, y: 5.2, z: 96 }],
      [{ x: 4.5, y: 1.4, z: 108 }, { x: 1.5, y: 5.2, z: 96 }],
    ];
    const walkwayRibs = [];
    for (let i = 0; i < 4; i++) {
      const z = 178 - i * 14;
      walkwayRibs.push(...createBoxEdges(0, 6, z, 24, 2.2, 4));
    }
    const doorLeft = createBoxEdges(-6, 13, 112, 10, 22, 3.2);
    const doorRight = createBoxEdges(6, 13, 112, 10, 22, 3.2);
    const exteriorRing = createBoxEdges(0, 24, 104, 38, 34, 6);
    const towerAnchors = [];
    towerAnchors.push(...createBoxEdges(-28, 20, 138, 4, 40, 78));
    towerAnchors.push(...createBoxEdges(28, 20, 138, 4, 40, 78));
    return {
      frame: edgesToFloat32(frame),
      sideSupports: edgesToFloat32(sideSupports),
      ceilingBeams: edgesToFloat32(ceilingBeams),
      floorGrid: edgesToFloat32(floorGrid),
      launchRails: edgesToFloat32(launchRails),
      walkwayRibs: edgesToFloat32(walkwayRibs),
      doorLeft: edgesToFloat32(doorLeft),
      doorRight: edgesToFloat32(doorRight),
      exteriorRing: edgesToFloat32(exteriorRing),
      towerAnchors: edgesToFloat32(towerAnchors),
    };
  }

  function createAsteroidCluster(cx, cy, cz, scale) {
    const pieces = [];
    const seeds = [
      { sx: 6, sy: 5, sz: 7, rx: 0.3, ry: 0.2, rz: 0.1, ox: 0, oy: 0, oz: 0 },
      { sx: 4, sy: 6, sz: 5, rx: -0.4, ry: 0.6, rz: 0.2, ox: 3, oy: 1.5, oz: -2 },
      { sx: 5, sy: 4, sz: 6, rx: 0.5, ry: -0.3, rz: -0.4, ox: -2.4, oy: -1.2, oz: 3.2 },
    ];
    for (const seed of seeds) {
      const base = createBoxEdges(0, 0, 0, seed.sx * scale, seed.sy * scale, seed.sz * scale);
      const rx = rotateEdgeListX(base, seed.rx);
      const rxy = rotateEdgeListY(rx, seed.ry);
      const rxyz = rotateEdgeListZ(rxy, seed.rz);
      pieces.push(...translateEdgeList(rxyz, cx + seed.ox * scale, cy + seed.oy * scale, cz + seed.oz * scale));
    }
    return pieces;
  }

  function createAsteroidRingEdges(cx, cy, cz, radius, thickness, segments) {
    const edges = [];
    for (let i = 0; i < segments; i++) {
      const a0 = (i / segments) * Math.PI * 2;
      const a1 = ((i + 1) / segments) * Math.PI * 2;
      const inner0 = { x: cx + Math.cos(a0) * (radius - thickness), y: cy + Math.sin(a0) * thickness * 0.3, z: cz + Math.sin(a0) * (radius - thickness) };
      const inner1 = { x: cx + Math.cos(a1) * (radius - thickness), y: cy + Math.sin(a1) * thickness * 0.3, z: cz + Math.sin(a1) * (radius - thickness) };
      const outer0 = { x: cx + Math.cos(a0) * (radius + thickness), y: cy + Math.sin(a0) * thickness * 0.6, z: cz + Math.sin(a0) * (radius + thickness) };
      const outer1 = { x: cx + Math.cos(a1) * (radius + thickness), y: cy + Math.sin(a1) * thickness * 0.6, z: cz + Math.sin(a1) * (radius + thickness) };
      edges.push([inner0, inner1]);
      edges.push([outer0, outer1]);
      edges.push([inner0, outer0]);
      edges.push([inner1, outer1]);
    }
    return edges;
  }

  function createSpaceCorridor(cx, cy, czStart, length, sections, halfWidth) {
    const edges = [];
    const step = length / sections;
    for (let i = 0; i < sections; i++) {
      const z0 = czStart - step * i;
      const z1 = z0 - step;
      const wobble = Math.sin((i / sections) * Math.PI * 2) * 4;
      const leftX = cx - halfWidth + wobble;
      const rightX = cx + halfWidth + wobble;
      const railY = cy + Math.sin((i * 0.8)) * 3;
      edges.push([
        { x: leftX, y: railY, z: z0 },
        { x: leftX, y: railY, z: z1 },
      ]);
      edges.push([
        { x: rightX, y: railY, z: z0 },
        { x: rightX, y: railY, z: z1 },
      ]);
      const crossCount = 3;
      for (let c = 1; c <= crossCount; c++) {
        const t = c / (crossCount + 1);
        const zCross = z0 + (z1 - z0) * t;
        const crossY = railY + Math.cos(t * Math.PI) * 2.4;
        edges.push([
          { x: leftX, y: crossY, z: zCross },
          { x: rightX, y: crossY, z: zCross },
        ]);
        edges.push([
          { x: cx, y: crossY - 6, z: zCross },
          { x: cx, y: crossY + 6, z: zCross },
        ]);
      }
    }
    return edges;
  }

  function generateStarField(count, spreadZ, offsetZ) {
    const stars = [];
    const baseZ = typeof offsetZ === "number" ? offsetZ : (player ? player.pos.z - 2000 : -2000);
    for (let i = 0; i < count; i++) {
      const x = (Math.random() * 2 - 1) * 240;
      const y = Math.random() * 220 + 40;
      const z = baseZ - Math.random() * spreadZ;
      stars.push({ x, y, z, twinkle: Math.random() * Math.PI * 2 });
    }
    return stars;
  }

  // === 辞書的なエッジ操作ユーティリティ ===
  function translateEdgeList(edges, dx, dy, dz) {
    return edges.map(([a, b]) => [
      { x: a.x + dx, y: a.y + dy, z: a.z + dz },
      { x: b.x + dx, y: b.y + dy, z: b.z + dz },
    ]);
  }

  function rotateEdgeListY(edges, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    return edges.map(([a, b]) => {
      const ax = a.x * cosA + a.z * sinA;
      const az = -a.x * sinA + a.z * cosA;
      const bx = b.x * cosA + b.z * sinA;
      const bz = -b.x * sinA + b.z * cosA;
      return [
        { x: ax, y: a.y, z: az },
        { x: bx, y: b.y, z: bz },
      ];
    });
  }

  function rotateEdgeListX(edges, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    return edges.map(([a, b]) => {
      const ay = a.y * cosA - a.z * sinA;
      const az = a.y * sinA + a.z * cosA;
      const by = b.y * cosA - b.z * sinA;
      const bz = b.y * sinA + b.z * cosA;
      return [
        { x: a.x, y: ay, z: az },
        { x: b.x, y: by, z: bz },
      ];
    });
  }

  function rotateEdgeListZ(edges, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    return edges.map(([a, b]) => {
      const ax = a.x * cosA - a.y * sinA;
      const ay = a.x * sinA + a.y * cosA;
      const bx = b.x * cosA - b.y * sinA;
      const by = b.x * sinA + b.y * cosA;
      return [
        { x: ax, y: ay, z: a.z },
        { x: bx, y: by, z: b.z },
      ];
    });
  }

  function edgesToFloat32(edges) {
    // エッジ配列をFloat32Arrayに格納して高速に走査できるようにする
    const buffer = new Float32Array(edges.length * 6);
    let p = 0;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = e[0];
      const b = e[1];
      buffer[p++] = a.x;
      buffer[p++] = a.y;
      buffer[p++] = a.z;
      buffer[p++] = b.x;
      buffer[p++] = b.y;
      buffer[p++] = b.z;
    }
    return buffer;
  }

  // === 敵シェイプ定義 ===
  function buildEnemyFighterShape() {
    // 小型戦闘機をローカル座標で定義（自機より短く薄い）
    return [
      [{ x: -6, y: 0, z: -3 }, { x: 6, y: 0, z: -3 }],
      [{ x: -3, y: 1.5, z: 0 }, { x: 0, y: -2, z: -10 }],
      [{ x: 3, y: 1.5, z: 0 }, { x: 0, y: -2, z: -10 }],
      [{ x: 0, y: -2, z: -10 }, { x: 0, y: 2.5, z: 4 }],
      [{ x: -2, y: 2.5, z: 4 }, { x: 2, y: 2.5, z: 4 }],
      [{ x: -1.5, y: -1, z: -6 }, { x: -1.5, y: 1, z: 2 }],
      [{ x: 1.5, y: -1, z: -6 }, { x: 1.5, y: 1, z: 2 }],
    ];
  }

  function buildGroundRobotShape() {
    // 二足歩行ロボを箱モジュールで表現
    const edges = [];
    edges.push(...createBoxEdges(0, 2.2, 0, 3.6, 4, 3)); // 胴体
    edges.push(...createBoxEdges(0, 4.6, -1.4, 2.8, 2.4, 2.4)); // 頭部
    edges.push(...createBoxEdges(-1.5, 0.8, 0, 1.2, 3.2, 1.2)); // 左脚
    edges.push(...createBoxEdges(1.5, 0.8, 0, 1.2, 3.2, 1.2)); // 右脚
    edges.push(...createBoxEdges(-2.4, 2.4, 0, 1.2, 1.2, 3.6)); // 左腕
    edges.push(...createBoxEdges(2.4, 2.4, 0, 1.2, 1.2, 3.6)); // 右腕
    return edges;
  }

  const enemyFighterShapeBase = buildEnemyFighterShape();
  const enemyFighterShape = edgesToFloat32(enemyFighterShapeBase);
  const enemyFighterShapeIncoming = edgesToFloat32(rotateEdgeListY(enemyFighterShapeBase, Math.PI));
  const enemyRobotShape = edgesToFloat32(buildGroundRobotShape());
  const bossTankShape = buildBossTank();
  const spaceBattleshipShape = buildSpaceBattleship();
  const finalBossFaceShape = buildFinalBossFace();

  function setupTankBoss() {
    boss.variant = "tank";
    boss.active = false;
    boss.destroyed = false;
    boss.spawnTriggerZ = -2400;
    boss.pos = { x: 0, y: 4, z: -3200 };
    boss.hp = 1200;
    boss.maxHp = 1200;
    boss.fireCooldown = 0;
    boss.fireInterval = 1.1;
    boss.shake = 0;
    boss.turretYaw = 0;
    boss.edges = bossTankShape.edges;
    boss.hitboxes = bossTankShape.hitboxes;
    boss.suctionActive = false;
    boss.suctionTimer = 0;
    boss.suctionDuration = 0;
    boss.suctionCooldown = 0;
    boss.suctionWarmup = 0;
    boss.suctionProgress = 0;
    boss.restZ = boss.pos.z;
    boss.chargeActive = false;
    boss.chargeTimer = 0;
    boss.chargeDuration = 0;
    boss.chargeCooldown = 0;
    boss.chargeOriginZ = boss.pos.z;
    boss.chargeTargetZ = boss.pos.z;
    boss.chargeProgress = 0;
    boss.chargeLaughed = false;
    boss.laughTimer = 0;
    boss.laughCooldown = 0;
    boss.waveCooldown = 0;
    boss.eyeLaserCooldown = 0;
  }

  function setupSpaceBattleship() {
    boss.variant = "battleship";
    boss.active = false;
    boss.destroyed = false;
    boss.spawnTriggerZ = -4200;
    boss.pos = { x: 0, y: 180, z: -5200 };
    boss.hp = 2600;
    boss.maxHp = 2600;
    boss.fireCooldown = 5.0;
    boss.fireInterval = 7.5;
    boss.waveCharge = 0;
    boss.shake = 0;
    boss.turretYaw = 0;
    boss.edges = spaceBattleshipShape.edges;
    boss.hitboxes = spaceBattleshipShape.hitboxes;
    boss.suctionActive = false;
    boss.suctionTimer = 0;
    boss.suctionDuration = 0;
    boss.suctionCooldown = 0;
    boss.suctionWarmup = 0;
    boss.suctionProgress = 0;
    boss.restZ = boss.pos.z;
    boss.chargeActive = false;
    boss.chargeTimer = 0;
    boss.chargeDuration = 0;
    boss.chargeCooldown = 0;
    boss.chargeOriginZ = boss.pos.z;
    boss.chargeTargetZ = boss.pos.z;
    boss.chargeProgress = 0;
    boss.chargeLaughed = false;
    boss.laughTimer = 0;
    boss.laughCooldown = 0;
    boss.waveCooldown = 0;
    boss.eyeLaserCooldown = 0;
  }

  function setupFinalBoss() {
    // 最終ボス（巨大な顔）の初期ステータスを構築
    boss.variant = "finalFace";
    boss.active = false;
    boss.destroyed = false;
    boss.spawnTriggerZ = -9999;
    boss.pos = { x: 0, y: 240, z: -5200 };
    boss.hp = 3200;
    boss.maxHp = 3200;
    boss.fireCooldown = 3.4;
    boss.fireInterval = 4.6;
    boss.waveCharge = 0;
    boss.shake = 0;
    boss.turretYaw = 0;
    boss.edges = finalBossFaceShape.edges;
    boss.hitboxes = finalBossFaceShape.hitboxes;
    boss.suctionActive = false;
    boss.suctionTimer = 0;
    boss.suctionDuration = 0;
    boss.suctionCooldown = 3.0;
    boss.suctionWarmup = 0;
    boss.suctionProgress = 0;
    boss.restZ = boss.pos.z;
    boss.chargeActive = false;
    boss.chargeTimer = 0;
    boss.chargeDuration = 0;
    boss.chargeCooldown = 4.5 + Math.random() * 2.0;
    boss.chargeOriginZ = boss.pos.z;
    boss.chargeTargetZ = boss.pos.z;
    boss.chargeProgress = 0;
    boss.chargeLaughed = false;
    boss.laughTimer = 0;
    boss.laughCooldown = 0;
    boss.waveCooldown = 0;
    boss.eyeLaserCooldown = 0;
  }

  setupTankBoss();

  function buildSpaceBattleship() {
    // 宇宙戦艦ボス（遠距離から波動砲を放つ）
    const hull = createBoxEdges(0, 0, 0, 120, 18, 280);
    const bridge = createBoxEdges(0, 12, -42, 36, 20, 64);
    const fins = [
      ...createBoxEdges(-54, -6, 40, 28, 6, 160),
      ...createBoxEdges(54, -6, 40, 28, 6, 160),
    ];
    const cannon = createBoxEdges(0, 8, -180, 18, 6, 140);
    const antenna = createBoxEdges(0, 24, -20, 4, 28, 8);
    const engines = [
      ...createBoxEdges(-24, -6, 120, 28, 14, 40),
      ...createBoxEdges(24, -6, 120, 28, 14, 40),
    ];
    const edges = {
      base: edgesToFloat32(hull),
      bridge: edgesToFloat32(bridge),
      fins: edgesToFloat32(fins),
      cannon: edgesToFloat32(cannon),
      antenna: edgesToFloat32(antenna),
      engines: edgesToFloat32(engines),
    };
    const hitboxes = [
      { min: { x: -60, y: -10, z: -140 }, max: { x: 60, y: 14, z: 140 }, weight: 1.0 },
      { min: { x: -20, y: 0, z: -210 }, max: { x: 20, y: 16, z: -80 }, weight: 1.4 },
      { min: { x: -32, y: -8, z: 90 }, max: { x: 32, y: 8, z: 150 }, weight: 1.2 },
    ];
    return { edges, hitboxes };
  }

  function buildFinalBossFace() {
    // 巨大な顔型ボスのワイヤーフレーム群を生成
    const outlineEdges = [];
    const segments = 28;
    const radiusX = 90;
    const radiusY = 70;
    const frontZ = -70;
    const innerZ = 40;
    for (let i = 0; i < segments; i++) {
      const a0 = (i / segments) * Math.PI * 2;
      const a1 = ((i + 1) / segments) * Math.PI * 2;
      const ax = Math.cos(a0) * radiusX;
      const ay = Math.sin(a0) * radiusY;
      const bx = Math.cos(a1) * radiusX;
      const by = Math.sin(a1) * radiusY;
      outlineEdges.push(
        [{ x: ax, y: ay, z: frontZ }, { x: bx, y: by, z: frontZ }],
        [{ x: ax * 0.9, y: ay * 0.94, z: innerZ }, { x: bx * 0.9, y: by * 0.94, z: innerZ }],
        [{ x: ax, y: ay, z: frontZ }, { x: ax * 0.85, y: ay * 0.88, z: innerZ }],
      );
    }
    const eyes = [
      ...createBoxEdges(-32, 18, -48, 26, 16, 8),
      ...createBoxEdges(32, 18, -48, 26, 16, 8),
    ];
    const nose = [
      ...createBoxEdges(0, 4, -36, 14, 30, 12),
      ...createBoxEdges(0, -12, -46, 10, 12, 16),
    ];
    const mouthEdges = [];
    const mouthSegments = 16;
    const mouthRadiusX = 48;
    const mouthRadiusY = 18;
    const mouthZ = -62;
    for (let i = 0; i < mouthSegments; i++) {
      const t0 = (i / mouthSegments) * Math.PI;
      const t1 = ((i + 1) / mouthSegments) * Math.PI;
      const ax = Math.cos(t0) * mouthRadiusX;
      const ay = Math.sin(t0) * mouthRadiusY - 38;
      const bx = Math.cos(t1) * mouthRadiusX;
      const by = Math.sin(t1) * mouthRadiusY - 38;
      mouthEdges.push([{ x: ax, y: ay, z: mouthZ }, { x: bx, y: by, z: mouthZ }]);
    }
    const crown = [];
    crown.push(...createBoxEdges(0, 74, -34, 60, 12, 44));
    for (let i = -2; i <= 2; i++) {
      const spikeX = i * 16;
      crown.push(
        [
          { x: spikeX, y: 86, z: -42 },
          { x: spikeX, y: 104, z: -60 },
        ],
        [
          { x: spikeX, y: 104, z: -60 },
          { x: spikeX + i * 2, y: 88, z: -24 },
        ],
      );
    }
    const edges = {
      outline: edgesToFloat32(outlineEdges),
      eyes: edgesToFloat32(eyes),
      nose: edgesToFloat32(nose),
      mouth: edgesToFloat32(mouthEdges),
      crown: edgesToFloat32(crown),
    };
    const hitboxes = [
      { min: { x: -84, y: -66, z: -90 }, max: { x: 84, y: 80, z: 52 }, weight: 1.0 },
      { min: { x: -34, y: -18, z: -92 }, max: { x: 34, y: 28, z: 18 }, weight: 1.3 },
    ];
    return { edges, hitboxes };
  }

  function resetGame() {
    // 通常進行用にゲーム全体を初期状態へ戻す
    setupTankBoss();
    stageClear = false;
    finalBossQueued = false;
    finalBossCountdown = 0;
    initStage0Scene();
  }

  function buildBossTank() {
    // 巨大戦車ボス（ビル街の終端に鎮座）
    const base = createBoxEdges(0, 2.5, 0, 52, 6, 82);
    const hull = createBoxEdges(0, 8, -6, 42, 8, 52);
    const turret = createBoxEdges(0, 12, -10, 28, 6, 36);
    const cannon = createBoxEdges(0, 12, -46, 6, 4, 60);
    const leftTread = createBoxEdges(-26, 2, 0, 8, 6, 90);
    const rightTread = createBoxEdges(26, 2, 0, 8, 6, 90);
    const antenna = createBoxEdges(10, 16, -4, 2, 10, 2);
    const edges = {
      base: edgesToFloat32(base),
      hull: edgesToFloat32(hull),
      turret: edgesToFloat32(turret),
      cannon: edgesToFloat32(cannon),
      treads: edgesToFloat32([...leftTread, ...rightTread]),
      antenna: edgesToFloat32(antenna),
    };
    const hitboxes = [
      { min: { x: -26, y: 0, z: -45 }, max: { x: 26, y: 12, z: 35 }, weight: 1.0 },
      { min: { x: -16, y: 8, z: -50 }, max: { x: 16, y: 16, z: -8 }, weight: 1.2 }, // 砲塔
      { min: { x: -4, y: 9, z: -86 }, max: { x: 4, y: 15, z: -36 }, weight: 1.5 }, // 砲身
    ];
    return { edges, hitboxes };
  }

  // === 敵の現在位置を取得（射撃や誘導用） ===
  function getEnemyPose(enemy) {
    if (!enemy) return null;
    if (enemy === boss || enemy.type === "boss") {
      if (boss.variant === "battleship") {
        return { x: boss.pos.x, y: boss.pos.y + 6, z: boss.pos.z - 140 };
      }
      // 戦車ボス（都市ステージ）のターゲット座標
      return { x: boss.pos.x, y: boss.pos.y + 8, z: boss.pos.z - 16 };
    }
    if (!enemy.base) return null;
    const freq = enemy.frequency || 1.0;
    const phase = enemy.phase || 0;
    const wave = Math.sin(simTime * freq + phase);
    const sway = Math.cos(simTime * freq * (enemy.type === "incoming" ? 0.6 : 0.7) + phase);
    let x = enemy.pathCenterX ?? enemy.base.x ?? 0;
    let y = enemy.base.y;
    let z = enemy.base.z;
    if (enemy.type === "air") {
      x = (enemy.pathCenterX ?? 0) + wave * (enemy.amplitudeX || 0);
      y += sway * (enemy.amplitudeY || 0);
    } else if (enemy.type === "ground") {
      x = (enemy.pathCenterX ?? 0) + wave * (enemy.amplitudeX || 0);
      y = Math.max(1.2, enemy.base.y + Math.abs(wave) * 1.2);
    } else if (enemy.type === "incoming") {
      x = (enemy.pathCenterX ?? 0) + wave * (enemy.amplitudeX || 0);
      y += sway * (enemy.amplitudeY || 0);
    } else if (enemy.type === "pursuer") {
      x = (enemy.base.x ?? 0) + wave * (enemy.amplitudeX || 0);
      y = (enemy.base.y ?? 0) + sway * (enemy.amplitudeY || 0);
    }
    x = clamp(x, -36, 36);
    return { x, y, z };
  }

  // === AIパネル向けの状態集計 ===
  function updateNearestEnemySnapshot() {
    let bestDist = Number.POSITIVE_INFINITY;
    let bestId = "NONE";
    const consider = (typeId, dist) => {
      if (!Number.isFinite(dist)) return;
      if (dist < bestDist) {
        bestDist = dist;
        bestId = (typeId || "UNK").toString().slice(0, 6);
      }
    };
    for (const enemy of enemyObjects) {
      if (!enemy) continue;
      const pose = getEnemyPose(enemy);
      if (!pose) continue;
      const dist = Math.abs(player.pos.z - pose.z);
      const typeId = enemy.typeId || enemy.variant || enemy.type || "UNK";
      consider(typeId, dist);
    }
    if (boss && boss.active && !boss.destroyed) {
      const dist = Math.abs(player.pos.z - boss.pos.z);
      const bossId = boss.variant || boss.type || "BOSS";
      consider(bossId, dist);
    }
    if (!Number.isFinite(bestDist)) {
      bestDist = 0;
      bestId = "NONE";
    }
    nearestEnemy.typeId = bestId;
    nearestEnemy.distance = Math.round(bestDist);
    return nearestEnemy;
  }

  function deriveStageCode() {
    switch (gamePhase) {
      case "stage0":
        return "HG";
      case "stage1":
        return "CT";
      case "cityExit":
        return "CX";
      case "stage2":
        return "SP";
      case "finalBoss":
        return "FB";
      case "finalClear":
        return "CL";
      case "soundTest":
        return "ST";
      case "gameOver":
        return "KO";
      default:
        return "??";
    }
  }

  function deriveEventCode() {
    if (gameOver) return 90;
    if (stageClear) return 80;
    if (boss && boss.active && !boss.destroyed) {
      if (boss.variant === "finalFace") return 75;
      return 70;
    }
    if (shieldFixBanner.active) return 40;
    if (rollState.active) return 30;
    return 10;
  }

  function collectAIPanelState() {
    const enemySnapshot = updateNearestEnemySnapshot();
    currentStage.code = deriveStageCode();
    currentEvent.code = deriveEventCode();
    return {
      hp: Math.max(0, Math.round(player.hp ?? 0)),
      enemyId: enemySnapshot.typeId,
      enemyDist: enemySnapshot.distance,
      stage: currentStage.code,
      event: currentEvent.code,
    };
  }

  function initAIPanelLoop() {
    if (!aiPanelCanvas || !aiPanelCtx || aiPanelTimer) return;
    aiPanelTimer = setInterval(() => {
      renderAIPanel(collectAIPanelState());
    }, 300);
  }

  // === プレイヤー武装ユーティリティ ===
  function spawnPlayerShot() {
    const speed = 420;
    const muzzles = [
      { x: -1.6, y: -0.8, z: -6 },
      { x: 1.6, y: -0.8, z: -6 },
    ];
    muzzles.forEach((off) => {
      // 自機レーザーの発光パラメータを付与
      playerShots.push({
        pos: { x: player.pos.x + off.x, y: player.pos.y + off.y, z: player.pos.z + off.z },
        vel: { x: off.x * 6, y: off.y * 4, z: -speed },
        ttl: 1.4,
        lifeMax: 1.4,
        beam: true,
        beamLength: 0.28,
        width: 3.6,
        color: "rgba(0, 255, 255, 0.9)",
        glowStart: "rgba(0, 200, 255, 0.55)",
        glowEnd: "rgba(0, 120, 255, 0.05)",
        coreColor: "rgba(255, 255, 255, 0.95)",
        shadowColor: "rgba(0, 180, 255, 0.85)",
        spawnTime: performance.now(),
        pulseSpeed: 8.0,
        pulseRange: 0.2,
        pulseOffset: Math.random() * Math.PI * 2,
      });
    });
    triggerLaserSfx("player");
  }

  function acquireMissileTarget() {
    let best = null;
    let bestScore = Infinity;
    const consider = (pose, ref, weight = 1.0) => {
      if (!pose) return;
      if (pose.z > player.pos.z + 40) return;
      const dz = player.pos.z - pose.z;
      if (dz < 20) return;
      const dx = player.pos.x - pose.x;
      const dy = player.pos.y - pose.y;
      const lateral = Math.hypot(dx, dy);
      const score = lateral * weight + dz * 0.35;
      if (score < bestScore) {
        bestScore = score;
        best = ref;
      }
    };
    for (const enemy of enemyObjects) {
      if (!enemy) continue;
      if (enemy.type === "ground") continue;
      const pose = getEnemyPose(enemy);
      consider(pose, enemy, enemy.type === "pursuer" ? 0.7 : 1.0);
    }
    if (boss.active && !boss.destroyed) {
      const bossPose = { x: boss.pos.x, y: boss.pos.y + 6, z: boss.pos.z - 20 };
      consider(bossPose, boss, 0.6);
    }
    return best;
  }

  function spawnPlayerMissile() {
    if (missileCooldown > 0) return;
    if (playerMissiles.length >= MAX_CONCURRENT_PLAYER_MISSILES) {
      // 画面上のミサイル数が上限に達している場合は追加発射しない
      return;
    }
    const target = acquireMissileTarget();
    if (!target) return;
    missilesRemaining -= 1;
    missileCooldown = MISSILE_FIRE_INTERVAL;
    const spawn = { x: player.pos.x, y: player.pos.y - 1.5, z: player.pos.z - 8 };
    playerMissiles.push({
      pos: { ...spawn },
      vel: { x: 0, y: 0, z: -140 },
      speed: 170,
      ttl: 6.0,
      target,
      turnRate: 4.0,
      trail: [],
    });
  }

  function spawnEnemyShot(enemy) {
    if (typeof enemy.hp === "number" && enemy.hp <= 0) return;
    const pose = getEnemyPose(enemy);
    if (!pose) return;
    const dx = player.pos.x - pose.x;
    const dy = player.pos.y - pose.y;
    const dz = player.pos.z - pose.z;
    const dist = Math.hypot(dx, dy, dz);
    if (dist < 1e-3) return;
    const isGround = enemy.type === "ground" || enemy.type === "walker";
    const speed = isGround ? 260 : 300;
    const vx = (dx / dist) * speed;
    const vy = (dy / dist) * speed;
    const vz = (dz / dist) * speed;
    // 敵ショットもレーザー光として強調
    enemyShots.push({
      pos: { x: pose.x, y: pose.y, z: pose.z },
      vel: { x: vx, y: vy, z: vz },
      ttl: isGround ? 2.4 : 2.0,
      lifeMax: isGround ? 2.4 : 2.0,
      beam: true,
      beamLength: isGround ? 0.22 : 0.3,
      width: isGround ? 2.8 : 3.2,
      color: "rgba(255, 110, 150, 0.9)",
      glowStart: "rgba(255, 70, 120, 0.55)",
      glowEnd: "rgba(255, 20, 60, 0.05)",
      coreColor: "rgba(255, 255, 255, 0.9)",
      shadowColor: "rgba(255, 90, 160, 0.85)",
      spawnTime: performance.now(),
      pulseSpeed: 6.4,
      pulseRange: 0.16,
      pulseOffset: Math.random() * Math.PI * 2,
      damage: enemy.shotDamage || (isGround ? 18 : 14),
      hitRadius: isGround ? 7 : 8,
    });
    triggerLaserSfx("enemy");
  }

  function updatePlayerWeapons(dt) {
    shotCooldown = Math.max(0, shotCooldown - dt);
    missileCooldown = Math.max(0, missileCooldown - dt);
    if (keys.has("Space") && shotCooldown <= 0) {
      spawnPlayerShot();
      shotCooldown = 0.12;
    }
    if (missileRequest) {
      spawnPlayerMissile();
    }
    missileRequest = false;
  }

  function updatePlayerRolling(dt) {
    // ローリング残り時間およびクールダウンを更新
    rollState.cooldown = Math.max(0, rollState.cooldown - dt);
    if (!rollState.active) return;
    rollState.timer = Math.max(0, rollState.timer - dt);
    const progress = clamp(1 - rollState.timer / rollState.duration, 0, 1);
    const eased = easeInOutCubic(progress);
    const spin = rollState.direction * rollState.rotationAngle * eased;
    player.roll = spin;
    if (rollState.timer <= 0) {
      rollState.active = false;
      player.roll = 0;
    }
  }

  function deflectEnemyShot(shot, nx, ny, nz) {
    // 正面法線を用いたシンプルな反射で敵弾を無効化
    const len = Math.hypot(nx, ny, nz) || 1;
    const ux = nx / len;
    const uy = ny / len;
    const uz = nz / len;
    const dot = shot.vel.x * ux + shot.vel.y * uy + shot.vel.z * uz;
    shot.vel.x -= 2 * dot * ux;
    shot.vel.y -= 2 * dot * uy;
    shot.vel.z -= 2 * dot * uz;
    shot.ttl = Math.min(shot.ttl, 0.4);
    shot.lifeMax = Math.max(shot.lifeMax || 0.4, shot.ttl);
    shot.damage = 0;
    shot.deflected = true;
    shot.color = "rgba(80, 220, 255, 0.95)";
    shot.glowStart = "rgba(0, 200, 255, 0.7)";
    shot.glowEnd = "rgba(0, 120, 255, 0.05)";
    shot.coreColor = "rgba(255, 255, 255, 0.8)";
    shot.shadowColor = "rgba(0, 180, 255, 0.75)";
    spawnExplosion(shot.pos.x, shot.pos.y, shot.pos.z, 0.6, 0.3);
  }

  function updateProjectiles(dt) {
    // レーザー進行
    for (let i = playerShots.length - 1; i >= 0; i--) {
      const shot = playerShots[i];
      if (!shot) {
        playerShots.splice(i, 1);
        continue;
      }
      shot.pos.x += shot.vel.x * dt;
      shot.pos.y += shot.vel.y * dt;
      shot.pos.z += shot.vel.z * dt;
      shot.ttl -= dt;
      if (boss.active && !boss.destroyed && !shot.absorbed) {
        const weight = pointInsideBoss(shot.pos.x, shot.pos.y, shot.pos.z);
        if (weight) {
          spawnExplosion(shot.pos.x, shot.pos.y, shot.pos.z, 0.9, 0.4);
          applyBossDamage(18 * weight);
          playerShots.splice(i, 1);
          continue;
        }
      }
      let enemyHit = false;
      for (let j = enemyObjects.length - 1; j >= 0; j--) {
        const enemy = enemyObjects[j];
        if (!enemy || typeof enemy.hp !== "number") continue;
        const pose = getEnemyPose(enemy);
        if (!pose) continue;
        const dx = pose.x - shot.pos.x;
        const dy = pose.y - shot.pos.y;
        const dz = pose.z - shot.pos.z;
        const dist = Math.hypot(dx, dy, dz);
        if (dist <= (enemy.hitRadius || 8)) {
          applyEnemyDamage(j, 30);
          playerShots.splice(i, 1);
          enemyHit = true;
          break;
        }
      }
      if (enemyHit) {
        continue;
      }
      if (shot.ttl <= 0 || shot.pos.z < player.pos.z - 900) {
        playerShots.splice(i, 1);
      }
    }
    // ミサイル誘導
    for (let i = playerMissiles.length - 1; i >= 0; i--) {
      const missile = playerMissiles[i];
      if (!missile) {
        playerMissiles.splice(i, 1);
        continue;
      }
      const target = missile.target;
      if (target) {
        const pose = getEnemyPose(target);
        if (pose && !(target === boss && boss.destroyed)) {
          const dx = pose.x - missile.pos.x;
          const dy = pose.y - missile.pos.y;
          const dz = pose.z - missile.pos.z;
          const dist = Math.hypot(dx, dy, dz);
          if (dist > 1e-3) {
            const desired = { x: dx / dist, y: dy / dist, z: dz / dist };
            missile.vel.x += (desired.x * missile.speed - missile.vel.x) * Math.min(1, dt * missile.turnRate);
            missile.vel.y += (desired.y * missile.speed - missile.vel.y) * Math.min(1, dt * missile.turnRate);
            missile.vel.z += (desired.z * missile.speed - missile.vel.z) * Math.min(1, dt * missile.turnRate);
          }
        } else {
          missile.target = null;
        }
      }
      missile.pos.x += missile.vel.x * dt;
      missile.pos.y += missile.vel.y * dt;
      missile.pos.z += missile.vel.z * dt;
      const trail = missile.trail || (missile.trail = []);
      const jitterX = (Math.random() - 0.5) * 1.2;
      const jitterY = (Math.random() - 0.5) * 0.7;
      const jitterZ = (Math.random() - 0.5) * 1.2;
      trail.push({
        x: missile.pos.x + jitterX,
        y: missile.pos.y + jitterY,
        z: missile.pos.z + jitterZ,
      });
      if (trail.length > 48) {
        trail.shift();
      }
      missile.ttl -= dt;
      if (boss.active && !boss.destroyed && !missile.absorbed) {
        const weight = pointInsideBoss(missile.pos.x, missile.pos.y, missile.pos.z);
        if (weight) {
          spawnExplosion(missile.pos.x, missile.pos.y, missile.pos.z, 2.0, 0.6);
          applyBossDamage(160 * weight);
          playerMissiles.splice(i, 1);
          continue;
        }
      }
      let missileEnemyHit = false;
      for (let j = enemyObjects.length - 1; j >= 0; j--) {
        const enemy = enemyObjects[j];
        if (!enemy || typeof enemy.hp !== "number") continue;
        const pose = getEnemyPose(enemy);
        if (!pose) continue;
        const dx = pose.x - missile.pos.x;
        const dy = pose.y - missile.pos.y;
        const dz = pose.z - missile.pos.z;
        const dist = Math.hypot(dx, dy, dz);
        if (dist <= (enemy.hitRadius ? enemy.hitRadius + 4 : 14)) {
          applyEnemyDamage(j, 220);
          playerMissiles.splice(i, 1);
          missileEnemyHit = true;
          break;
        }
      }
      if (missileEnemyHit) {
        continue;
      }
      if (missile.ttl <= 0 || missile.pos.z < player.pos.z - 1000) {
        playerMissiles.splice(i, 1);
      }
    }
    // 敵ショット進行
    for (let i = enemyShots.length - 1; i >= 0; i--) {
      const shot = enemyShots[i];
      if (!shot) {
        enemyShots.splice(i, 1);
        continue;
      }
      shot.pos.x += shot.vel.x * dt;
      shot.pos.y += shot.vel.y * dt;
      shot.pos.z += shot.vel.z * dt;
      shot.ttl -= dt;
      if (gamePhase !== "stage0" && gamePhase !== "gameOver") {
        const dx = shot.pos.x - player.pos.x;
        const dy = shot.pos.y - player.pos.y;
        const dz = shot.pos.z - player.pos.z;
        const dist = Math.hypot(dx, dy, dz);
        const hitRange = shot.hitRadius || (player.hitRadius + 3);
        if (dist <= hitRange && !shot.deflected) {
          if (rollState.active) {
            deflectEnemyShot(shot, dx, dy, dz);
            continue;
          }
          applyPlayerDamage(shot.damage || 12, shot);
          enemyShots.splice(i, 1);
          continue;
        }
      }
      if (shot.ttl <= 0 || shot.pos.z > player.pos.z + 200 || shot.pos.z < player.pos.z - 1000) {
        enemyShots.splice(i, 1);
      }
    }
  }

  function drawLaserProjectiles(list, defaultColor, width, lengthScale) {
    if (!list.length) return;
    ctx.save();
    const now = performance.now();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineCap = "round";
    for (const shot of list) {
      const head = projectPoint(shot.pos);
      if (!head) continue;
      const len = shot.beam ? (shot.beamLength || lengthScale * 2.6) : lengthScale;
      const tailPoint = {
        x: shot.pos.x - shot.vel.x * len,
        y: shot.pos.y - shot.vel.y * len,
        z: shot.pos.z - shot.vel.z * len,
      };
      const tail = projectPoint(tailPoint);
      if (!tail) continue;

      const baseColor = shot.color || defaultColor;
      const glowStart = shot.glowStart || baseColor;
      const glowEnd = shot.glowEnd || "rgba(0, 0, 0, 0)";
      const coreColor = shot.coreColor || "rgba(255, 255, 255, 0.9)";
      const pulseSpeed = shot.pulseSpeed || 0;
      const pulseRange = shot.pulseRange || 0;
      const pulseOffset = shot.pulseOffset || 0;
      const lifeMax = shot.lifeMax || shot.ttl || 1;
      const lifeRatio = Math.max(0, Math.min(1, (shot.ttl ?? lifeMax) / lifeMax));
      const elapsed = now - (shot.spawnTime || now);
      const pulseFactor = 1 + (pulseSpeed ? Math.sin(elapsed * 0.001 * pulseSpeed + pulseOffset) * pulseRange : 0);
      const beamWidth = (shot.width || width) * pulseFactor * (0.7 + lifeRatio * 0.6);

      // レーザー外縁の発光グラデーションを描画
      const glowGradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
      glowGradient.addColorStop(0, glowStart);
      glowGradient.addColorStop(0.45, baseColor);
      glowGradient.addColorStop(1, glowEnd);
      ctx.shadowColor = shot.shadowColor || glowStart;
      ctx.shadowBlur = (shot.beam ? 32 : 16) * pulseFactor * (0.6 + lifeRatio * 0.5);
      ctx.lineWidth = beamWidth * (shot.beam ? 1.6 : 1.1);
      ctx.strokeStyle = glowGradient;
      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
      ctx.stroke();

      // レーザー中心の熱量を細いコアとして重ね書き
      const coreGradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
      coreGradient.addColorStop(0, coreColor);
      coreGradient.addColorStop(1, "rgba(255, 255, 255, 0.18)");
      ctx.shadowBlur = (shot.beam ? 20 : 10) * pulseFactor * (0.5 + lifeRatio * 0.5);
      ctx.lineWidth = beamWidth * 0.65;
      ctx.strokeStyle = coreGradient;
      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.lineWidth = Math.max(0.9, beamWidth * 0.28);
      ctx.strokeStyle = coreColor;
      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
      ctx.stroke();

      // 着弾点の閃光を小さな円で付与
      ctx.shadowColor = shot.shadowColor || baseColor;
      ctx.shadowBlur = 14 * pulseFactor;
      ctx.fillStyle = coreColor;
      ctx.beginPath();
      ctx.arc(head.x, head.y, Math.max(1.2, beamWidth * 0.5), 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  // === ミサイル描画 ===
  function drawMissiles(list) {
    if (!list.length) return;
    ctx.save();
    for (const missile of list) {
      const trail = missile.trail;
      if (trail && trail.length >= 2) {
        for (let i = 1; i < trail.length; i++) {
          const prev = projectPoint(trail[i - 1]);
          const curr = projectPoint(trail[i]);
          if (!prev || !curr) continue;
          const t = 1 - i / trail.length;
          ctx.lineWidth = 1.2 + t * 2.8;
          ctx.strokeStyle = `rgba(60, 140, 255, ${0.04 + t * 0.22})`;
          ctx.shadowColor = `rgba(40, 120, 255, ${0.24 * t})`;
          ctx.shadowBlur = 12 * t;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();

          ctx.lineWidth = 0.8 + t * 1.6;
          ctx.strokeStyle = `rgba(140, 220, 255, ${0.06 + t * 0.32})`;
          ctx.shadowColor = `rgba(80, 200, 255, ${0.18 * t})`;
          ctx.shadowBlur = 16 * t;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();

          ctx.lineWidth = 0.4 + t * 0.9;
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.04 + t * 0.2})`;
          ctx.shadowColor = `rgba(200, 255, 255, ${0.14 * t})`;
          ctx.shadowBlur = 8 * t;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();
        }
      }
    }

    ctx.lineWidth = 2.6;
    ctx.strokeStyle = "rgba(255, 200, 120, 0.95)";
    ctx.shadowColor = "rgba(255, 180, 100, 0.9)";
    ctx.shadowBlur = 18;
    ctx.beginPath();
    for (const missile of list) {
      const head = projectPoint(missile.pos);
      if (!head) continue;
      const tailPos = {
        x: missile.pos.x - missile.vel.x * 0.03,
        y: missile.pos.y - missile.vel.y * 0.03,
        z: missile.pos.z - missile.vel.z * 0.03,
      };
      const tail = projectPoint(tailPos);
      if (!tail) continue;
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // === 最終ボスの口アニメーション描画 ===
  function drawFinalBossLaughMouth(openRatio) {
    const basePoint = bossLocalToWorld(0, -36, -60);
    const center = projectPoint(basePoint);
    if (!center) return;
    const left = projectPoint(bossLocalToWorld(-44, -36, -60));
    const right = projectPoint(bossLocalToWorld(44, -36, -60));
    const top = projectPoint(bossLocalToWorld(0, -30 + openRatio * 8, -60));
    const bottom = projectPoint(bossLocalToWorld(0, -45 - openRatio * 20, -60));
    if (!left || !right || !top || !bottom) return;
    const halfWidth = Math.max(6, Math.abs(right.x - left.x) * 0.5);
    const mouthCenterY = (top.y + bottom.y) * 0.5;
    const halfHeight = Math.max(5, Math.abs(bottom.y - top.y) * 0.5);
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(center.x, mouthCenterY, halfWidth, halfHeight, 0, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(0, 40, 110, ${0.45 + openRatio * 0.25})`;
    ctx.strokeStyle = `rgba(0, 220, 255, ${0.6 + openRatio * 0.3})`;
    ctx.lineWidth = 2.4;
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawPlayerStatusOverlay(hpText, shieldText, stockText) {
    const scale = Math.max(canvas.width / 1280, canvas.height / 720);
    const panelWidth = canvas.width * 0.22;
    const barHeight = 10 * scale;
    const gap = 14 * scale;
    const baseX = 32 * scale;
    const baseY = canvas.height - 70 * scale;
    const hpRatio = player.maxHp > 0 ? clamp(player.hp / player.maxHp, 0, 1) : 0;
    const shieldRatio = player.maxShield > 0 ? clamp(player.shield / player.maxShield, 0, 1) : 0;
    const panelHeight = 96 * scale;
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(4, 12, 28, 0.7)";
    ctx.fillRect(baseX - 14 * scale, baseY - 32 * scale, panelWidth + 28 * scale, panelHeight);
    ctx.strokeStyle = "rgba(0, 120, 255, 0.6)";
    ctx.lineWidth = 1.4 * scale;
    ctx.strokeRect(baseX - 14 * scale, baseY - 32 * scale, panelWidth + 28 * scale, panelHeight);

    ctx.fillStyle = "rgba(0, 255, 220, 0.18)";
    ctx.fillRect(baseX, baseY - gap, panelWidth, barHeight);
    ctx.fillStyle = "rgba(0, 255, 220, 0.85)";
    ctx.fillRect(baseX, baseY - gap, panelWidth * hpRatio, barHeight);

    ctx.fillStyle = "rgba(0, 180, 255, 0.16)";
    ctx.fillRect(baseX, baseY + barHeight * 0.6, panelWidth, barHeight);
    ctx.fillStyle = "rgba(0, 180, 255, 0.82)";
    ctx.fillRect(baseX, baseY + barHeight * 0.6, panelWidth * shieldRatio, barHeight);

    ctx.fillStyle = "rgba(200, 240, 255, 0.88)";
    ctx.font = `${14 * scale}px "Helvetica Neue", system-ui, sans-serif`;
    ctx.textBaseline = "bottom";
    ctx.fillText(hpText, baseX, baseY - gap - 4 * scale);
    ctx.textBaseline = "top";
    ctx.fillText(shieldText, baseX, baseY + barHeight * 0.6 + 4 * scale);
    ctx.fillText(stockText, baseX, baseY + barHeight * 1.9 + 4 * scale);
    ctx.restore();
  }

  // === 星背景描画 ===
  function drawStars(alpha) {
    if (!spaceScene.stars.length || alpha <= 0.01) return;
    ctx.save();
    ctx.shadowBlur = 0;
    for (const star of spaceScene.stars) {
      const projected = projectPoint(star);
      if (!projected) continue;
      const pulse = 0.5 + Math.sin(star.twinkle + simTime * 2.0) * 0.5;
      const brightness = (0.25 + 0.75 * pulse) * alpha;
      ctx.fillStyle = `rgba(140, 210, 255, ${0.18 + 0.42 * brightness})`;
      ctx.beginPath();
      ctx.arc(projected.x, projected.y, 0.8 + brightness * 1.6, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // === 宇宙環境（アステロイド等）描画 ===
  function drawSpaceScenery(alpha) {
    if (alpha <= 0.01) return;
    for (const obj of spaceScene.objects) {
      if (obj.type === "platform") {
        drawEdges(obj.edges, `rgba(0, 220, 255, ${0.42 * alpha})`, 2.0, `rgba(0, 255, 255, ${0.36 * alpha})`);
      } else {
        drawEdges(obj.edges, `rgba(0, 150, 255, ${0.26 * alpha})`, 1.6, `rgba(0, 120, 255, ${0.22 * alpha})`);
      }
    }
    for (const corridor of spaceScene.corridors) {
      drawEdges(corridor.edges, `rgba(0, 255, 245, ${0.42 * alpha})`, 2.8, `rgba(0, 255, 230, ${0.48 * alpha})`);
    }
    for (const ring of spaceScene.rings) {
      drawEdges(ring.edges, `rgba(0, 255, 230, ${0.5 * alpha})`, 3.0, `rgba(0, 255, 200, ${0.55 * alpha})`);
    }
  }

  function drawGuideBeacons(alpha) {
    if (!spaceScene.guideBeacons.length || alpha <= 0.01) return;
    ctx.save();
    for (const beacon of spaceScene.guideBeacons) {
      const pulse = 0.6 + Math.sin(spaceScene.guidePhase + beacon.phase) * 0.4;
      const proj = projectPoint(beacon);
      if (!proj) continue;
      const radius = 4 + pulse * 3;
      ctx.fillStyle = `rgba(0, 255, 255, ${0.25 * alpha + pulse * 0.2})`;
      ctx.shadowColor = `rgba(0, 200, 255, ${0.55 * alpha})`;
      ctx.shadowBlur = 28 * alpha * pulse;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }
  function getBossEdgeGroups() {
    if (!boss.active && !boss.destroyed) return null;
    const offset = boss.pos;
    const shake = boss.shake || 0;
    const sx = (Math.random() - 0.5) * shake * 0.4;
    const sy = (Math.random() - 0.5) * shake * 0.2;
    const sz = (Math.random() - 0.5) * shake * 0.3;
    const baseTransform = { tx: offset.x + sx, ty: offset.y + sy, tz: offset.z + sz };
    if (boss.variant === "battleship") {
      const yaw = boss.turretYaw || 0;
      const yawTransform = { ...baseTransform, yaw };
      return {
        variant: "battleship",
        base: { edges: boss.edges.base, transform: baseTransform },
        bridge: { edges: boss.edges.bridge, transform: baseTransform },
        fins: { edges: boss.edges.fins, transform: baseTransform },
        engines: { edges: boss.edges.engines, transform: baseTransform },
        cannon: { edges: boss.edges.cannon, transform: yawTransform },
        antenna: { edges: boss.edges.antenna, transform: yawTransform },
      };
    }
    if (boss.variant === "finalFace") {
      const yaw = boss.turretYaw || 0;
      const yawTransform = { ...baseTransform, yaw };
      return {
        variant: "finalFace",
        outline: { edges: boss.edges.outline, transform: yawTransform },
        eyes: { edges: boss.edges.eyes, transform: yawTransform },
        nose: { edges: boss.edges.nose, transform: yawTransform },
        mouth: { edges: boss.edges.mouth, transform: yawTransform },
        crown: { edges: boss.edges.crown, transform: yawTransform },
      };
    }
    const yaw = boss.turretYaw || 0;
    const yawTransform = { ...baseTransform, yaw };
    return {
      variant: "tank",
      base: { edges: boss.edges.base, transform: baseTransform },
      hull: { edges: boss.edges.hull, transform: baseTransform },
      treads: { edges: boss.edges.treads, transform: baseTransform },
      turret: { edges: boss.edges.turret, transform: yawTransform },
      cannon: { edges: boss.edges.cannon, transform: yawTransform },
      antenna: { edges: boss.edges.antenna, transform: yawTransform },
    };
  }

  function pointInsideBoss(px, py, pz) {
    if (!boss.active || boss.destroyed) return false;
    const lx = px - boss.pos.x;
    const ly = py - boss.pos.y;
    const lz = pz - boss.pos.z;
    for (const hb of boss.hitboxes) {
      if (lx >= hb.min.x && lx <= hb.max.x &&
          ly >= hb.min.y && ly <= hb.max.y &&
          lz >= hb.min.z && lz <= hb.max.z) {
        return hb.weight || 1.0;
      }
    }
    return 0;
  }

  function applyBossDamage(amount) {
    if (!boss.active || boss.destroyed) return;
    boss.hp = Math.max(0, boss.hp - amount);
    boss.shake = 0.6;
    if (boss.hp <= 0) {
      boss.destroyed = true;
      enemyShots.length = 0;
      if (boss.variant === "battleship") {
        for (let i = 0; i < 14; i++) {
          const ox = (Math.random() - 0.5) * 90;
          const oy = Math.random() * 50 - 10;
          const oz = (Math.random() - 0.5) * 160;
          spawnExplosion(boss.pos.x + ox, boss.pos.y + oy, boss.pos.z + oz, 5.4, 1.6);
        }
        prepareFinalBossTransition();
      } else if (boss.variant === "finalFace") {
        for (let i = 0; i < 18; i++) {
          const ox = (Math.random() - 0.5) * 140;
          const oy = (Math.random() - 0.2) * 120;
          const oz = (Math.random() - 0.5) * 140;
          spawnExplosion(boss.pos.x + ox, boss.pos.y + oy, boss.pos.z + oz, 4.0, 1.4);
        }
        triggerFinalVictory();
      } else {
        for (let i = 0; i < 8; i++) {
          const ox = (Math.random() - 0.5) * 24;
          const oy = Math.random() * 10 + 4;
          const oz = (Math.random() - 0.5) * 28;
          spawnExplosion(boss.pos.x + ox, boss.pos.y + oy, boss.pos.z + oz, 3.2, 1.1);
        }
        triggerCityBossDefeat();
      }
    }
  }

  // === シティボス撃破処理 ===
  function triggerCityBossDefeat() {
    stage1Clear = true;
    stopStageMusic();
    triggerCityExitFanfare();
    gamePhase = "cityExit";
    phaseTime = 0;
    cityExitState.progress = 0;
    cityExitState.passed = false;
    initCityExitVisuals();
    enemyObjects.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    shieldPickups.length = 0;
  }

  // === 最終撃破処理 ===
  function triggerFinalVictory() {
    stageClear = true;
    stageClearTime = performance.now();
    gamePhase = "finalClear";
    phaseTime = 0;
    enemyObjects.length = 0;
    enemyShots.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    shieldPickups.length = 0;
  }

  function applyEnemyDamage(enemyIndex, amount) {
    const enemy = enemyObjects[enemyIndex];
    if (!enemy) return false;
    if (typeof enemy.hp !== "number") return false;
    enemy.hp = Math.max(0, enemy.hp - amount);
    enemy.hitFlash = 0.45;
    if (enemy.hp <= 0) {
      const pose = getEnemyPose(enemy);
      if (pose) {
        spawnExplosion(pose.x, pose.y, pose.z, 1.2, 0.7);
        if (enemy.dropShield) {
          spawnShieldPickup(pose.x, pose.y, pose.z, enemy.shieldReward || 35);
        }
      }
      enemyObjects.splice(enemyIndex, 1);
      return true;
    }
    return false;
  }

  function applyPlayerDamage(amount, source) {
    if (stageClear || gamePhase === "stage0" || gamePhase === "finalClear" || gamePhase === "gameOver") return;
    if (player.invuln > 0) return;
    let remaining = amount;
    if (player.shield > 0) {
      const absorbed = Math.min(player.shield, remaining);
      player.shield -= absorbed;
      remaining -= absorbed;
    }
    if (remaining > 0) {
      player.hp = Math.max(0, player.hp - remaining);
    }
    const explosionScale = Math.min(1.8, 0.6 + amount * 0.02);
    spawnExplosion(player.pos.x, player.pos.y, player.pos.z - 6, explosionScale, 0.45 + amount * 0.01);
    camera.shake = Math.max(camera.shake, 0.9);
    player.invuln = 0.9;
    if (player.hp <= 0) {
      handlePlayerLifeLoss();
    }
  }

  function handlePlayerLifeLoss() {
    player.stocks = Math.max(0, player.stocks - 1);
    if (player.stocks > 0) {
      respawnPlayer();
    } else {
      triggerPlayerGameOver();
    }
  }

  function triggerPlayerGameOver() {
    if (gameOver) return;
    gameOver = true;
    stopStageMusic();
    gameOverTime = performance.now();
    gamePhase = "gameOver";
    phaseTime = 0;
    stageClear = false;
    stage1Clear = false;
    missilesRemaining = MISSILE_STOCK_MAX;
    player.stocks = 0;
    player.hp = 0;
    player.shield = 0;
    player.invuln = 2.0;
    player.visible = false; // 自機を非表示にしてゲームオーバー演出を明確化
    enemyShots.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    enemyObjects.length = 0;
    shieldPickups.length = 0;
    for (let i = 0; i < 6; i++) {
      const ox = (Math.random() - 0.5) * 14;
      const oy = Math.random() * 8;
      const oz = (Math.random() - 0.5) * 12 - 6;
      spawnExplosion(player.pos.x + ox, player.pos.y + oy, player.pos.z + oz, 2 + i * 0.45, 0.6 + i * 0.12);
    }
  }

  function spawnExplosion(x, y, z, scale = 1.0, duration = 0.7) {
    const count = 18;
    const shards = [];
    if (scale >= 0.8 || (scale >= 0.4 && Math.random() < 0.35)) {
      triggerExplosionSfx(scale);
    }
    for (let i = 0; i < count; i++) {
      let vx = Math.random() * 2 - 1;
      let vy = Math.random() * 2 - 1;
      let vz = Math.random() * 2 - 1;
      const mag = Math.hypot(vx, vy, vz) || 1;
      vx /= mag;
      vy /= mag;
      vz /= mag;
      const len = (0.6 + Math.random() * 0.6) * scale;
      shards.push({ dir: { x: vx, y: vy, z: vz }, len });
    }
    const rings = [];
    for (let r = 0; r < 3; r++) {
      rings.push({
        baseRadius: scale * (0.7 + r * 0.55) * (0.8 + Math.random() * 0.4),
        tilt: (Math.random() * Math.PI) - Math.PI / 2,
        height: (Math.random() * 1.4 - 0.2) * scale,
      });
    }
    explosions.push({ pos: { x, y, z }, shards, rings, age: 0, duration, scale });
  }

  // === シールド回復アイテム生成 ===
  function spawnShieldPickup(x, y, z, amount) {
    // 敵撃破時に出現するシールド補給カプセルを蓄積（視認性向上のため半径を拡大）
    const baseY = y;
    shieldPickups.push({
      pos: { x, y, z },
      baseY,
      amount,
      phase: Math.random() * Math.PI * 2,
      ttl: 9.0,
      radius: 16,
    });
  }

  // === シールド回復アイテム更新 ===
  function updateShieldPickups(dt) {
    if (!shieldPickups.length) return;
    for (let i = shieldPickups.length - 1; i >= 0; i--) {
      const pickup = shieldPickups[i];
      pickup.ttl -= dt;
      pickup.phase = (pickup.phase + dt * 2.6) % (Math.PI * 2);
      pickup.pos.y = (pickup.baseY ?? pickup.pos.y) + Math.sin(pickup.phase * 3) * 4;
      if (pickup.ttl <= 0 || pickup.pos.z > player.pos.z + 80) {
        shieldPickups.splice(i, 1);
        continue;
      }
      const dx = player.pos.x - pickup.pos.x;
      const dy = player.pos.y - pickup.pos.y;
      const dz = player.pos.z - pickup.pos.z;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= pickup.radius + player.hitRadius) {
        // シールドを回復してドロップを消滅させる
        player.shield = Math.min(player.maxShield, player.shield + pickup.amount);
        player.invuln = Math.max(player.invuln, 0.4);
        triggerShieldFixSfx();
        shieldFixBanner.active = true;
        shieldFixBanner.time = 0;
        shieldFixBanner.duration = 1.5;
        shieldFixBanner.colorPhase = 0;
        shieldFixBanner.text = "SHIELD FIX";
        spawnExplosion(pickup.pos.x, pickup.pos.y, pickup.pos.z, 0.38, 0.3);
        shieldPickups.splice(i, 1);
      }
    }
  }

  // === シールド回復アイテム描画 ===
  function drawShieldPickups() {
    if (!shieldPickups.length) return;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const pickup of shieldPickups) {
      const head = projectPoint(pickup.pos);
      if (!head) continue;
      const pulse = 0.6 + Math.sin(pickup.phase * 4) * 0.2;
      const radius = (pickup.radius + 6) * pulse;

      // 中央の輝きを強調するグラデーションリング
      const glow = ctx.createRadialGradient(head.x, head.y, 0, head.x, head.y, radius);
      glow.addColorStop(0, "rgba(0, 255, 255, 0.92)");
      glow.addColorStop(0.45, "rgba(0, 190, 255, 0.55)");
      glow.addColorStop(1, "rgba(0, 120, 255, 0)");
      ctx.shadowColor = "rgba(0, 220, 255, 0.95)";
      ctx.shadowBlur = 36 * pulse;
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(head.x, head.y, radius, 0, Math.PI * 2);
      ctx.fill();

      // 回転する六角形ハイライトで目立たせる
      ctx.save();
      ctx.translate(head.x, head.y);
      ctx.rotate(pickup.phase * 2);
      ctx.lineWidth = 2.4;
      ctx.strokeStyle = "rgba(255, 255, 255, 0.92)";
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI * 2 * i) / 6;
        const px = Math.cos(angle) * radius * 0.82;
        const py = Math.sin(angle) * radius * 0.82;
        if (i === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      }
      ctx.closePath();
      ctx.stroke();

      // 縦方向のライトスキャンを追加して瞬時に視線を誘導
      const beamHeight = radius * 1.8;
      ctx.lineWidth = 3.4;
      ctx.strokeStyle = "rgba(0, 255, 255, 0.85)";
      ctx.beginPath();
      ctx.moveTo(0, -beamHeight * 0.5);
      ctx.lineTo(0, beamHeight * 0.5);
      ctx.stroke();
      ctx.restore();

      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  function drawShieldFixBanner() {
    // シールド補給取得時のバナーを中央付近に表示
    if (!shieldFixBanner.active) return;
    const progress = clamp(shieldFixBanner.time / Math.max(0.0001, shieldFixBanner.duration), 0, 1);
    const alpha = Math.max(0, 1 - progress);
    if (alpha <= 0.01) return;
    const wobble = Math.sin(shieldFixBanner.colorPhase) * 0.06;
    const text = shieldFixBanner.text;
    const fontSize = 48;
    ctx.save();
    ctx.translate(canvas.width * 0.5, canvas.height * 0.26);
    ctx.scale(1 + wobble, 1 + wobble * 0.4);
    ctx.globalAlpha = alpha;
    ctx.font = `${fontSize}px "Helvetica Neue", system-ui, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const padX = 36;
    const padY = 24;
    const boxY = -fontSize * 0.7;
    const boxH = fontSize + padY;
    ctx.shadowColor = `rgba(0, 255, 255, ${0.7 + Math.sin(shieldFixBanner.colorPhase * 1.5) * 0.18})`;
    ctx.shadowBlur = 34;
    ctx.fillStyle = "rgba(0, 28, 70, 0.6)";
    ctx.fillRect(-textWidth * 0.5 - padX, boxY, textWidth + padX * 2, boxH);
    ctx.strokeStyle = "rgba(0, 255, 255, 0.85)";
    ctx.lineWidth = 2.6;
    ctx.strokeRect(-textWidth * 0.5 - padX, boxY, textWidth + padX * 2, boxH);
    const textGradient = ctx.createLinearGradient(-textWidth * 0.5, 0, textWidth * 0.5, 0);
    textGradient.addColorStop(0, "rgba(210, 255, 255, 0.96)");
    textGradient.addColorStop(1, "rgba(120, 220, 255, 0.92)");
    ctx.shadowBlur = 12;
    ctx.shadowColor = "rgba(0, 255, 255, 0.65)";
    ctx.fillStyle = textGradient;
    ctx.fillText(text, 0, -fontSize * 0.12);
    ctx.restore();
  }

  function advanceShieldFixBanner(dt) {
    // SHIELD FIXバナーの寿命とアニメーションを管理
    if (!shieldFixBanner.active) return;
    shieldFixBanner.time += dt;
    shieldFixBanner.colorPhase = (shieldFixBanner.colorPhase + dt * 8.2) % (Math.PI * 2);
    if (shieldFixBanner.time >= shieldFixBanner.duration) {
      shieldFixBanner.active = false;
      shieldFixBanner.time = 0;
      shieldFixBanner.colorPhase = 0;
    }
  }

  function updateExplosions(dt) {
    for (let i = explosions.length - 1; i >= 0; i--) {
      const exp = explosions[i];
      exp.age += dt;
      if (exp.age >= exp.duration) {
        explosions.splice(i, 1);
      }
    }
  }

  // === シティオブジェクトとの衝突判定 ===
  function checkCityCollisions() {
    if (player.invuln > 0) return;
    for (const obj of cityObjects) {
      if (obj.type !== "building" || !obj.position || !obj.halfSize) continue;
      const minZ = obj.position.z - obj.halfSize.z - player.hitRadius;
      if (minZ > player.pos.z) continue;
      const maxZ = obj.position.z + obj.halfSize.z + player.hitRadius;
      if (maxZ < player.pos.z) continue;
      const minX = obj.position.x - obj.halfSize.x;
      const maxX = obj.position.x + obj.halfSize.x;
      const minY = obj.position.y - obj.halfSize.y;
      const maxY = obj.position.y + obj.halfSize.y;
      const clampedX = clamp(player.pos.x, minX, maxX);
      const clampedY = clamp(player.pos.y, minY, maxY);
      const clampedZ = clamp(player.pos.z, obj.position.z - obj.halfSize.z, obj.position.z + obj.halfSize.z);
      const dx = player.pos.x - clampedX;
      const dy = player.pos.y - clampedY;
      const dz = player.pos.z - clampedZ;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= player.hitRadius) {
        applyPlayerDamage(32, obj);
        camera.shake = Math.max(camera.shake, 1.1);
        break;
      }
    }
  }

  // === 宇宙アステロイドとの衝突判定 ===
  function checkSpaceCollisions() {
    if (player.invuln > 0) return;
    for (const obj of spaceScene.objects) {
      if (obj.type !== "asteroid" || !obj.center || !obj.radius) continue;
      const dx = player.pos.x - obj.center.x;
      const dy = player.pos.y - obj.center.y;
      const dz = player.pos.z - obj.center.z;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= obj.radius + player.hitRadius) {
        applyPlayerDamage(36, obj);
        camera.shake = Math.max(camera.shake, 1.2);
        break;
      }
    }
  }

  function resetPlayerVitals(fullRestore = true) {
    // 自機のシールドとHPを所定値にリセット
    player.hp = player.maxHp;
    player.shield = player.maxShield;
    player.invuln = 0;
    shieldFixBanner.active = false;
    shieldFixBanner.time = 0;
    shieldFixBanner.colorPhase = 0;
    if (fullRestore) {
      missilesRemaining = MISSILE_STOCK_MAX;
      player.stocks = player.maxStocks;
    }
    player.visible = true; // 復活時には自機を再表示する
  }

  function respawnPlayer() {
    resetPlayerVitals(false);
    player.invuln = Math.max(player.invuln, 1.5);
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    shotCooldown = 0;
    missileCooldown = 0;
    missileRequest = false;
    enemyShots.length = 0;
    spawnExplosion(player.pos.x, player.pos.y, player.pos.z - 10, 1.8, 0.6);
  }

  // === ステージ0制御 ===
  function initStage0Scene() {
    gamePhase = "stage0";
    phaseTime = 0;
    stage1Clear = false;
    stageClear = false;
    gameOver = false;
    gameOverTime = 0;
    stage0State.doorProgress = 0;
    stage0State.launchProgress = 0;
    stage0State.thruster = 0;
    player.pos.x = 0;
    player.pos.y = stage0State.startY;
    player.pos.z = stage0State.startZ;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    resetPlayerVitals();
    missileRequest = false;
    shotCooldown = 0;
    missileCooldown = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    enemyShots.length = 0;
    explosions.length = 0;
    shieldPickups.length = 0;
    camera.pos.x = 4;
    camera.pos.y = player.pos.y + 6;
    camera.pos.z = player.pos.z + 56;
    camera.shake = 0;
    environment = "city";
    skyMix = 0;
    stage1Events.chaseSpawned = false;
    queueStage0Jingle();
  }

  function updateStage0(dt) {
    if (stage0JinglePending && !stage0JinglePlayed) {
      // サスペンド解除済みなら即時ジングル再生を試行
      tryPlayStage0Jingle();
    }
    const t = phaseTime;
    const doorStart = 0.9;
    const doorEnd = 2.6;
    const launchStart = 2.8;
    const launchDuration = 3.8;
    const thrusterStart = 2.4;

    const doorRatio = (t - doorStart) / Math.max(doorEnd - doorStart, 0.1);
    stage0State.doorProgress = easeInOutCubic(clamp(doorRatio, 0, 1));
    stage0State.thruster = smoothstep((t - thrusterStart) / 0.9);
    const launchRatio = (t - launchStart) / Math.max(launchDuration, 0.1);
    const launchProgress = easeInOutCubic(clamp(launchRatio, 0, 1));
    stage0State.launchProgress = launchProgress;

    const lateralDrift = Math.sin(t * 0.6) * (1 - launchProgress) * 1.4;
    player.pos.x = lateralDrift;
    player.pos.z = stage0State.startZ + (stage0State.targetZ - stage0State.startZ) * launchProgress;
    const riseRatio = easeOutCubic((t - launchStart) / (launchDuration * 0.7));
    player.pos.y = stage0State.startY + (stage0State.targetY - stage0State.startY) * riseRatio;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = clamp(Math.sin(t * 1.3) * (1 - launchProgress) * 0.18, -0.3, 0.3);

    const camLag = 54 - launchProgress * 32;
    camera.pos.x = player.pos.x * 0.5 - Math.sin(t * 0.4) * (1 - launchProgress) * 3.2;
    camera.pos.y = player.pos.y + 6 + (1 - launchProgress) * 4.2 - stage0State.thruster * 1.6;
    camera.pos.z = player.pos.z + camLag;
    camera.shake = Math.max(camera.shake * Math.pow(0.25, dt), stage0State.thruster * 0.35);

    updatePlayerRolling(dt);

    if (launchProgress >= 1 && t >= launchStart + launchDuration + 0.5) {
      enterStage1();
    }
  }

  function enterStage1() {
    if (gamePhase !== "stage0") return;
    gamePhase = "stage1";
    phaseTime = 0;
    player.pos.x = 0;
    player.pos.y = stage0State.targetY;
    player.pos.z = stage0State.targetZ;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    resetPlayerVitals();
    missileRequest = false;
    shotCooldown = 0;
    missileCooldown = 0;
    missilesRemaining = MISSILE_STOCK_MAX;
    initCityEnemies();
    queueStage1Music();
    stage1Events.chaseSpawned = false;
  }

  function drawExplosions() {
    if (!explosions.length) return;
    ctx.save();
    for (const exp of explosions) {
      const t = exp.age / exp.duration;
      const fade = Math.max(0, 1 - t);
      const center = { x: exp.pos.x, y: exp.pos.y, z: exp.pos.z };
      for (const shard of exp.shards) {
        const stretch = shard.len * (0.6 + t * 2.4);
        const tailStretch = shard.len * (0.2 + t * 0.6);
        const head = {
          x: center.x + shard.dir.x * stretch,
          y: center.y + shard.dir.y * stretch,
          z: center.z + shard.dir.z * stretch,
        };
        const tail = {
          x: center.x + shard.dir.x * tailStretch,
          y: center.y + shard.dir.y * tailStretch,
          z: center.z + shard.dir.z * tailStretch,
        };
        const pHead = projectPoint(head);
        const pTail = projectPoint(tail);
        if (!pHead || !pTail) continue;
        ctx.lineWidth = 1.0 + exp.scale * (0.8 + t * 1.2);
        ctx.strokeStyle = `rgba(255, 220, 120, ${0.08 + fade * 0.42})`;
        ctx.shadowColor = `rgba(255, 200, 120, ${0.2 * fade})`;
        ctx.shadowBlur = 18 * fade;
        ctx.beginPath();
        ctx.moveTo(pTail.x, pTail.y);
        ctx.lineTo(pHead.x, pHead.y);
        ctx.stroke();

        ctx.lineWidth = 0.8 + exp.scale * (0.6 + t * 0.9);
        ctx.strokeStyle = `rgba(0, 200, 255, ${0.05 + fade * 0.28})`;
        ctx.shadowColor = `rgba(0, 150, 255, ${0.18 * fade})`;
        ctx.shadowBlur = 12 * fade;
        ctx.beginPath();
        ctx.moveTo(pTail.x, pTail.y);
        ctx.lineTo(pHead.x, pHead.y);
        ctx.stroke();
      }

      for (const ring of exp.rings || []) {
        const segs = 28;
        const radius = ring.baseRadius * (0.25 + t * 1.5);
        const cosTilt = Math.cos(ring.tilt);
        const sinTilt = Math.sin(ring.tilt);
        let prevPoint = null;
        for (let s = 0; s <= segs; s++) {
          const phi = (s / segs) * Math.PI * 2;
          const lx = Math.cos(phi) * radius;
          const lz = Math.sin(phi) * radius;
          const ly = -lz * sinTilt;
          const wz = lz * cosTilt;
          const worldPoint = {
            x: center.x + lx,
            y: center.y + ring.height + ly,
            z: center.z + wz,
          };
          const proj = projectPoint(worldPoint);
          if (!proj) {
            prevPoint = null;
            continue;
          }
          if (prevPoint) {
            const energy = fade * (1 - Math.abs(s / segs - 0.5) * 0.2);
            ctx.lineWidth = 1.2 + exp.scale * (0.5 + 0.6 * fade);
            ctx.strokeStyle = `rgba(0, 200, 255, ${0.04 + energy * 0.22})`;
            ctx.shadowColor = `rgba(0, 140, 255, ${0.2 * energy})`;
            ctx.shadowBlur = 14 * energy;
            ctx.beginPath();
            ctx.moveTo(prevPoint.x, prevPoint.y);
            ctx.lineTo(proj.x, proj.y);
            ctx.stroke();

            ctx.lineWidth = 0.8 + exp.scale * (0.3 + 0.4 * fade);
            ctx.strokeStyle = `rgba(255, 230, 160, ${0.05 + energy * 0.18})`;
            ctx.shadowColor = `rgba(255, 210, 140, ${0.16 * energy})`;
            ctx.shadowBlur = 10 * energy;
            ctx.beginPath();
            ctx.moveTo(prevPoint.x, prevPoint.y);
            ctx.lineTo(proj.x, proj.y);
            ctx.stroke();
          }
          prevPoint = proj;
        }
      }

      const core = projectPoint(center);
      if (core) {
        const coreAlpha = 0.12 + fade * 0.4;
        ctx.lineWidth = 0;
        ctx.fillStyle = `rgba(255, 255, 255, ${coreAlpha})`;
        ctx.shadowColor = `rgba(0, 200, 255, ${0.4 * fade})`;
        ctx.shadowBlur = 32 * fade;
        ctx.beginPath();
        ctx.arc(core.x, core.y, 12 * exp.scale * fade, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.restore();
  }

  function bossLocalToWorld(x, y, z) {
    const yaw = boss.turretYaw || 0;
    const cosA = Math.cos(yaw);
    const sinA = Math.sin(yaw);
    const rx = x * cosA + z * sinA;
    const rz = -x * sinA + z * cosA;
    return {
      x: boss.pos.x + rx,
      y: boss.pos.y + y,
      z: boss.pos.z + rz,
    };
  }

  function spawnBossShell() {
    if (!boss.active || boss.destroyed) return;
    const muzzle = bossLocalToWorld(0, 12, -84);
    const targetX = player.pos.x;
    const targetY = player.pos.y;
    const targetZ = player.pos.z;
    const dx = targetX - muzzle.x;
    const dy = targetY - muzzle.y;
    const dz = targetZ - muzzle.z;
    const dist = Math.hypot(dx, dy, dz);
    if (dist < 1e-3) return;
    const speed = 340;
    // ボスタンク砲もレーザー化して迫力を追加
    enemyShots.push({
      pos: muzzle,
      vel: { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed },
      ttl: 2.6,
      lifeMax: 2.6,
      beam: true,
      beamLength: 0.34,
      width: 4.2,
      color: "rgba(255, 120, 160, 0.92)",
      glowStart: "rgba(255, 120, 200, 0.6)",
      glowEnd: "rgba(255, 70, 140, 0.05)",
      coreColor: "rgba(255, 255, 255, 0.92)",
      shadowColor: "rgba(255, 100, 190, 0.85)",
      spawnTime: performance.now(),
      pulseSpeed: 5.4,
      pulseRange: 0.22,
      pulseOffset: Math.random() * Math.PI * 2,
      damage: 32,
      hitRadius: 10,
    });
  }

  // === 戦艦波動砲発射 ===
  function spawnWaveCannon() {
    if (!boss.active || boss.destroyed) return;
    const muzzle = bossLocalToWorld(0, 18, -210);
    const target = {
      x: player.pos.x,
      y: player.pos.y,
      z: player.pos.z,
    };
    const dx = target.x - muzzle.x;
    const dy = target.y - muzzle.y;
    const dz = target.z - muzzle.z;
    const dist = Math.hypot(dx, dy, dz) || 1;
    const speed = 520;
    // 波動砲は長尺ビームとして描画
    enemyShots.push({
      pos: { ...muzzle },
      vel: { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed },
      ttl: 1.6,
      lifeMax: 1.6,
      beam: true,
      beamLength: 1.6,
      width: 22,
      color: "rgba(0, 210, 255, 0.96)",
      glowStart: "rgba(0, 220, 255, 0.72)",
      glowEnd: "rgba(0, 140, 255, 0.12)",
      coreColor: "rgba(255, 255, 255, 0.96)",
      shadowColor: "rgba(0, 180, 255, 0.9)",
      spawnTime: performance.now(),
      pulseSpeed: 4.2,
      pulseRange: 0.25,
      pulseOffset: Math.random() * Math.PI * 2,
      damage: 60,
      hitRadius: 18,
    });
    boss.waveCharge = 1;
    boss.shake = 1.6;
  }

  function updateBoss(dt) {
    if (boss.variant === "battleship") {
      updateBattleshipBoss(dt);
      return;
    }
    if (boss.variant === "finalFace") {
      updateFinalBossFace(dt);
      return;
    }
    if (boss.destroyed) {
      boss.shake = Math.max(0, boss.shake - dt * 1.8);
      return;
    }
    if (!boss.active && player.pos.z <= boss.spawnTriggerZ) {
      boss.active = true;
      queueStage3Music();
    }
    if (!boss.active) return;
    boss.shake = Math.max(0, boss.shake - dt * 1.8);
    const dx = player.pos.x - boss.pos.x;
    const dz = player.pos.z - boss.pos.z;
    const targetYaw = Math.atan2(dx, -(dz || 1e-3));
    boss.turretYaw += (targetYaw - boss.turretYaw) * Math.min(1, dt * 2.6);
    boss.fireCooldown -= dt;
    if (boss.fireCooldown <= 0 && !stageClear) {
      spawnBossShell();
      boss.fireCooldown = boss.fireInterval + Math.random() * 0.4;
    }
  }

  // === 戦艦ボス挙動 ===
  function updateBattleshipBoss(dt) {
    if (boss.destroyed) {
      boss.shake = Math.max(0, boss.shake - dt * 1.2);
      boss.waveCharge = Math.max(0, boss.waveCharge - dt * 2.2);
      return;
    }
    if (!boss.active && player.pos.z <= boss.spawnTriggerZ) {
      boss.active = true;
      queueStage3Music();
    }
    if (!boss.active) return;
    boss.shake = Math.max(0, boss.shake - dt * 0.8);
    const dx = player.pos.x - boss.pos.x;
    const dz = player.pos.z - boss.pos.z;
    const targetYaw = Math.atan2(dx, -(dz || 1e-3));
    boss.turretYaw += (targetYaw - boss.turretYaw) * Math.min(1, dt * 1.6);
    boss.fireCooldown -= dt;
    boss.waveCharge = Math.max(0, boss.waveCharge - dt * 1.4);
    const targetY = Math.max(150, Math.min(220, player.pos.y - 8));
    boss.pos.y += (targetY - boss.pos.y) * Math.min(1, dt * 0.6);
    const targetZ = player.pos.z - 520;
    boss.pos.z += (targetZ - boss.pos.z) * Math.min(1, dt * 0.4);
    if (boss.fireCooldown <= 0 && !stageClear) {
      spawnWaveCannon();
      boss.fireCooldown = boss.fireInterval + Math.random() * 1.6;
    }
  }

  // === 最終ボス挙動 ===
  function updateFinalBossFace(dt) {
    if (boss.destroyed) {
      boss.shake = Math.max(0, boss.shake - dt * 1.1);
      return;
    }
    if (!boss.active) {
      boss.active = true;
      queueStage3Music();
    }
    boss.shake = Math.max(0, boss.shake - dt * 1.4);
    boss.laughTimer = Math.max(0, boss.laughTimer - dt);
    boss.laughCooldown = Math.max(0, boss.laughCooldown - dt);
    boss.waveCooldown = Math.max(0, boss.waveCooldown - dt);
    boss.eyeLaserCooldown = Math.max(0, boss.eyeLaserCooldown - dt);
    const dx = player.pos.x - boss.pos.x;
    const dz = player.pos.z - boss.pos.z;
    const targetYaw = Math.atan2(dx, -(dz || 1e-3));
    boss.turretYaw += (targetYaw - boss.turretYaw) * Math.min(1, dt * 1.2);
    const hoverY = 220 + Math.sin(simTime * 0.6) * 10;
    boss.pos.y += (hoverY - boss.pos.y) * Math.min(1, dt * 0.5);

    // 突進中は前進・後退フェーズに応じてZ位置を補間
    if (boss.chargeActive) {
      boss.chargeTimer += dt;
      const half = Math.max(0.0001, boss.chargeDuration * 0.5);
      if (boss.chargeTimer <= half) {
        const prog = smoothstep(boss.chargeTimer / half);
        boss.pos.z = boss.chargeOriginZ + (boss.chargeTargetZ - boss.chargeOriginZ) * prog;
        boss.chargeProgress = prog * 0.5;
      } else {
        const retreatProg = smoothstep((boss.chargeTimer - half) / half);
        if (!boss.chargeLaughed) {
          boss.laughTimer = 1.6;
          boss.chargeLaughed = true;
          boss.laughCooldown = 4.5 + Math.random() * 2.5;
        }
        boss.pos.z = boss.chargeTargetZ + (boss.restZ - boss.chargeTargetZ) * retreatProg;
        boss.chargeProgress = 0.5 + retreatProg * 0.5;
      }
      if (boss.chargeTimer >= boss.chargeDuration) {
        boss.chargeActive = false;
        boss.chargeTimer = 0;
        boss.chargeDuration = 0;
        boss.chargeProgress = 0;
        boss.pos.z = boss.restZ;
        boss.chargeCooldown = 6.0 + Math.random() * 4.0;
        boss.chargeLaughed = false;
      }
    } else {
      // 待機時は元の位置へゆるやかに戻す
      boss.pos.z += (boss.restZ - boss.pos.z) * Math.min(1, dt * 0.8);
      boss.chargeProgress = Math.max(0, boss.chargeProgress - dt * 0.6);
      boss.chargeCooldown = Math.max(0, boss.chargeCooldown - dt);
      if (boss.chargeCooldown <= 0 && !boss.suctionActive && !stageClear) {
        boss.chargeActive = true;
        boss.chargeTimer = 0;
        boss.chargeDuration = 3.0 + Math.random() * 0.8;
        boss.chargeOriginZ = boss.pos.z;
        const desired = player.pos.z - 120;
        const nearCap = boss.restZ + 640;
        const farCap = boss.restZ + 320;
        boss.chargeTargetZ = clamp(desired, farCap, nearCap);
        boss.chargeProgress = 0;
        boss.chargeLaughed = false;
        boss.laughTimer = 0;
      }
    }

    boss.fireCooldown -= dt;
    if (boss.suctionActive) {
      boss.suctionTimer += dt;
      boss.suctionProgress = clamp(boss.suctionTimer / Math.max(0.001, boss.suctionDuration), 0, 1);
      if (boss.suctionWarmup > 0) {
        boss.suctionWarmup = Math.max(0, boss.suctionWarmup - dt);
      }
      applyFinalBossSuction(dt);
      if (boss.suctionTimer >= boss.suctionDuration) {
        boss.suctionActive = false;
        boss.suctionTimer = 0;
        boss.suctionDuration = 0;
        boss.suctionCooldown = 5 + Math.random() * 2.5;
        boss.suctionProgress = 0;
        for (const shot of playerShots) {
          if (shot && shot.absorbed) delete shot.absorbed;
        }
        for (const missile of playerMissiles) {
          if (missile && missile.absorbed) delete missile.absorbed;
        }
      }
    } else {
      boss.suctionCooldown = Math.max(0, boss.suctionCooldown - dt);
      if (boss.suctionCooldown <= 0 && !stageClear && !boss.chargeActive) {
        boss.suctionActive = true;
        boss.suctionTimer = 0;
        boss.suctionDuration = 2.6;
        boss.suctionWarmup = 0.45;
        boss.suctionProgress = 0;
        triggerLaserSfx("enemy");
      }
    }
    const playerDistance = player.pos.z - boss.pos.z;
    const farDistance = playerDistance > finalBossDistanceConstraint.max - 20;
    const canAttack = !boss.suctionActive && !boss.chargeActive && !stageClear;
    if (canAttack && farDistance && boss.waveCooldown <= 0) {
      spawnFinalBossWave();
      boss.waveCooldown = 6.0 + Math.random() * 2.5;
      boss.shake = Math.max(boss.shake, 1.6);
      boss.fireCooldown = Math.max(boss.fireCooldown, 1.2);
      boss.eyeLaserCooldown = Math.max(boss.eyeLaserCooldown, 1.8);
    } else if (canAttack && boss.eyeLaserCooldown <= 0) {
      spawnFinalBossEyeLasers();
      boss.eyeLaserCooldown = 2.6 + Math.random() * 1.4;
      boss.fireCooldown = Math.max(boss.fireCooldown, 0.7);
    }
    if (!boss.suctionActive && !boss.chargeActive && boss.fireCooldown <= 0 && !stageClear) {
      spawnFinalBossBurst();
      boss.fireCooldown = boss.fireInterval + Math.random() * 0.8;
    }
  }

  // === 最終ボス吸い込み処理 ===
  function applyFinalBossSuction(dt) {
    const origin = bossLocalToWorld(0, -10, -68);
    const pull = 6 + boss.suctionProgress * 16;
    for (let i = playerShots.length - 1; i >= 0; i--) {
      const shot = playerShots[i];
      if (!shot) {
        playerShots.splice(i, 1);
        continue;
      }
      shot.absorbed = true;
      const dx = origin.x - shot.pos.x;
      const dy = origin.y - shot.pos.y;
      const dz = origin.z - shot.pos.z;
      const dist = Math.hypot(dx, dy, dz);
      const factor = Math.min(1, dt * pull);
      shot.pos.x += dx * factor;
      shot.pos.y += dy * factor;
      shot.pos.z += dz * factor;
      shot.vel.x *= 0.2;
      shot.vel.y *= 0.2;
      shot.vel.z *= 0.2;
      shot.ttl = Math.min(shot.ttl, 0.5);
      if (dist < 16) {
        playerShots.splice(i, 1);
      }
    }
    for (let i = playerMissiles.length - 1; i >= 0; i--) {
      const missile = playerMissiles[i];
      if (!missile) {
        playerMissiles.splice(i, 1);
        continue;
      }
      missile.absorbed = true;
      missile.target = null;
      const dx = origin.x - missile.pos.x;
      const dy = origin.y - missile.pos.y;
      const dz = origin.z - missile.pos.z;
      const dist = Math.hypot(dx, dy, dz);
      const factor = Math.min(1, dt * (pull * 0.8));
      missile.pos.x += dx * factor;
      missile.pos.y += dy * factor;
      missile.pos.z += dz * factor;
      missile.vel.x *= 0.25;
      missile.vel.y *= 0.25;
      missile.vel.z *= 0.25;
      missile.ttl = Math.min(missile.ttl, 0.7);
      if (dist < 22) {
        playerMissiles.splice(i, 1);
      }
    }
  }

  // === 最終ボス射撃パターン ===
  function spawnFinalBossBurst() {
    if (!boss.active || boss.destroyed) return;
    const emitters = [
      bossLocalToWorld(-28, 18, -62),
      bossLocalToWorld(28, 18, -62),
      bossLocalToWorld(0, -24, -72),
    ];
    const speed = 260;
    for (const emitter of emitters) {
      const dx = player.pos.x - emitter.x;
      const dy = player.pos.y - emitter.y;
      const dz = player.pos.z - emitter.z;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= 1e-3) continue;
      enemyShots.push({
        pos: { ...emitter },
        vel: { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed },
        ttl: 1.8,
        lifeMax: 1.8,
        beam: true,
        beamLength: 0.34,
        width: 3.6,
        color: "rgba(255, 150, 220, 0.92)",
        glowStart: "rgba(0, 200, 255, 0.62)",
        glowEnd: "rgba(0, 120, 255, 0.1)",
        coreColor: "rgba(255, 255, 255, 0.95)",
        shadowColor: "rgba(0, 180, 255, 0.88)",
        spawnTime: performance.now(),
        pulseSpeed: 7.6,
        pulseRange: 0.18,
        pulseOffset: Math.random() * Math.PI * 2,
        damage: 22,
        hitRadius: 10,
      });
    }
    triggerLaserSfx("enemy");
  }

  // === 最終ボス波動砲（遠距離時） ===
  function spawnFinalBossWave() {
    if (!boss.active || boss.destroyed) return;
    const base = bossLocalToWorld(0, -6, -80);
    const spread = 44;
    const lanes = 5;
    for (let i = 0; i < lanes; i++) {
      const offset = (i - (lanes - 1) * 0.5) / ((lanes - 1) * 0.5 || 1);
      const muzzle = {
        x: base.x + offset * spread,
        y: base.y + Math.sin(offset * Math.PI * 0.5) * 12,
        z: base.z,
      };
      const dx = player.pos.x - muzzle.x;
      const dy = (player.pos.y - 8) - muzzle.y;
      const dz = (player.pos.z - 4) - muzzle.z;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= 1e-3) continue;
      const speed = 360;
      enemyShots.push({
        pos: { ...muzzle },
        vel: { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed },
        ttl: 2.3,
        lifeMax: 2.3,
        beam: true,
        beamLength: 0.56,
        width: 5.8,
        color: "rgba(0, 220, 255, 0.95)",
        glowStart: "rgba(0, 255, 255, 0.75)",
        glowEnd: "rgba(0, 120, 255, 0.08)",
        coreColor: "rgba(255, 255, 255, 0.95)",
        shadowColor: "rgba(0, 200, 255, 0.92)",
        spawnTime: performance.now(),
        pulseSpeed: 8.2,
        pulseRange: 0.22,
        pulseOffset: Math.random() * Math.PI * 2,
        damage: 40,
        hitRadius: 18,
      });
    }
    triggerLaserSfx("enemy");
  }

  // === 最終ボス目からのレーザー発射 ===
  function spawnFinalBossEyeLasers() {
    if (!boss.active || boss.destroyed) return;
    const eyes = [
      bossLocalToWorld(-24, 18, -52),
      bossLocalToWorld(24, 18, -52),
    ];
    const speed = 420;
    eyes.forEach((eye, idx) => {
      const aimY = player.pos.y + (idx === 0 ? -8 : 8);
      const dx = player.pos.x - eye.x;
      const dy = aimY - eye.y;
      const dz = player.pos.z - eye.z;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= 1e-3) return;
      enemyShots.push({
        pos: { ...eye },
        vel: { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed },
        ttl: 1.9,
        lifeMax: 1.9,
        beam: true,
        beamLength: 0.44,
        width: 3.4,
        color: "rgba(255, 150, 255, 0.95)",
        glowStart: "rgba(150, 220, 255, 0.7)",
        glowEnd: "rgba(0, 120, 255, 0.08)",
        coreColor: "rgba(255, 255, 255, 0.97)",
        shadowColor: "rgba(160, 220, 255, 0.9)",
        spawnTime: performance.now(),
        pulseSpeed: 10.6,
        pulseRange: 0.28,
        pulseOffset: Math.random() * Math.PI * 2,
        damage: 24,
        hitRadius: 12,
      });
    });
    triggerLaserSfx("enemy");
  }

  // === 都市レーン構築 ===
  function initCity() {
    cityObjects.length = 0;
    const laneWidth = 36;
    const blockDepth = 140; // ブロック間隔を広げて進行距離を延伸
    const laneCount = 16; // ビル密集地帯を終えた先にボスエリアを配置
    for (let i = 0; i < laneCount; i++) {
      const z = -i * blockDepth - 80;
      // 左右にビル群を配置
      for (const side of [-1, 1]) {
        const baseX = side * (laneWidth * 0.7);
        const towerCount = 3;
        for (let t = 0; t < towerCount; t++) {
          const offsetX = baseX + side * (Math.random() * 12 + t * 6);
          const baseY = Math.random() * 4;
          const height = 40 + Math.random() * 80;
          const width = 10 + Math.random() * 14;
          const depth = 10 + Math.random() * 14;
          const centerZ = z - t * 12;
          cityObjects.push({
            type: "building",
            zOrigin: z,
            position: { x: offsetX, y: height * 0.5 + baseY, z: centerZ },
            halfSize: { x: width * 0.5, y: height * 0.5, z: depth * 0.5 },
            edges: createBoxEdges(offsetX, height * 0.5 + baseY, centerZ, width, height, depth),
          });
        }
      }
    }
    // ゲートを中央レーンに配置
    const gateZ = -960; // ゲートを遠方へ移動してフライト時間を確保
    cityObjects.push({
      type: "gate",
      zOrigin: gateZ,
      edges: edgesToFloat32(createGateEdges(0, 24, gateZ, 40, 32, 8, 4)),
    });
    // 地面グリッド
    cityObjects.push({
      type: "ground",
      zOrigin: 0,
      edges: edgesToFloat32(createGroundGrid(20, -3800, 20, 90)),
    });
  }

  // === シールドキャリア抽選 ===
  function maybeAssignShieldCarrier(enemy, chance = 0.18) {
    if (!enemy || enemy.dropShield) return;
    if (Math.random() >= chance) return;
    enemy.dropShield = true;
    enemy.shieldReward = enemy.shieldReward || 40;
    if (typeof enemy.maxHp === "number") {
      enemy.maxHp = Math.round(enemy.maxHp * 1.2);
      enemy.hp = enemy.maxHp;
    } else if (typeof enemy.hp === "number") {
      enemy.hp = Math.round(enemy.hp * 1.2);
    }
  }

  function initCityEnemies() {
    enemyObjects.length = 0;
    // 空中戦闘機
    const airSpawns = [-360, -520, -720];
    airSpawns.forEach((z, idx) => {
      const side = idx % 2 === 0 ? 1 : -1;
      const enemy = {
        type: "air",
        shape: enemyFighterShape,
        base: { x: side * 18, y: 20, z },
        pathCenterX: side * 18,
        amplitudeX: 16,
        amplitudeY: 4,
        frequency: 0.9 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2,
        fireInterval: 1.3 + Math.random() * 0.6,
        fireCooldown: Math.random() * 1.0,
        hp: 80,
        maxHp: 80,
        hitRadius: 11,
        hitFlash: 0,
      };
      maybeAssignShieldCarrier(enemy, 0.16);
      enemyObjects.push(enemy);
    });
    // 地上ロボット
    const groundSpawns = [-430, -660];
    groundSpawns.forEach((z, idx) => {
      const side = idx % 2 === 0 ? -1 : 1;
      const enemy = {
        type: "ground",
        shape: enemyRobotShape,
        base: { x: side * 28, y: 2.2, z },
        pathCenterX: side * 28,
        amplitudeX: 10,
        frequency: 1.4 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2,
        fireInterval: 1.7 + Math.random() * 0.5,
        fireCooldown: Math.random() * 1.2,
        hp: 120,
        maxHp: 120,
        hitRadius: 12,
        hitFlash: 0,
      };
      maybeAssignShieldCarrier(enemy, 0.14);
      enemyObjects.push(enemy);
    });
    // 画面手前に迫る航空機編隊
    const formationOffsets = [
      { x: 0, y: 0, z: 0 },
      { x: -9, y: -1.5, z: -18 },
      { x: 9, y: -1.5, z: -18 },
      { x: -14, y: -2.5, z: -34 },
      { x: 14, y: -2.5, z: -34 },
    ];
    const resetDistance = 1250;
    formationOffsets.forEach((offset, idx) => {
      const enemy = {
        type: "incoming",
        shape: enemyFighterShapeIncoming,
        base: { x: offset.x, y: 22 + offset.y, z: player.pos.z - resetDistance + offset.z },
        pathCenterX: offset.x,
        amplitudeX: 4,
        amplitudeY: 2.8,
        frequency: 1.05 + idx * 0.07,
        phase: idx * 0.45,
        speed: 210,
        resetDistance,
        formationOffset: offset,
        originalX: offset.x,
        fireInterval: 0.9 + Math.random() * 0.4,
        fireCooldown: Math.random() * 0.8,
        hp: 90,
        maxHp: 90,
        hitRadius: 10,
        hitFlash: 0,
      };
      maybeAssignShieldCarrier(enemy, 0.12);
      enemyObjects.push(enemy);
    });
    // 後方から追尾するエース機
    const pursuer = {
      type: "pursuer",
      shape: enemyFighterShape,
      base: { x: player.pos.x, y: player.pos.y + 8, z: player.pos.z + 28 },
      amplitudeX: 2.5,
      amplitudeY: 1.8,
      frequency: 1.4,
      phase: Math.random() * Math.PI * 2,
      trailDistance: 24,
      chaseLerp: 4.0,
      chaseLerpZ: 2.6,
      swayFreq: 1.7,
      swayAmp: 6,
      fireInterval: 0.75 + Math.random() * 0.35,
      fireCooldown: 1.0,
      hp: 150,
      maxHp: 150,
      hitRadius: 12,
      hitFlash: 0,
    };
    maybeAssignShieldCarrier(pursuer, 0.2);
    enemyObjects.push(pursuer);
  }

  function spawnStage1ChaseEnemy() {
    // ステージ1中盤で背後から突入し即座に追い越すエース機を生成
    const exitX = clamp((Math.random() * 2 - 1) * 28, -32, 32);
    const chaser = {
      type: "chaseAce",
      shape: enemyFighterShape,
      base: { x: player.pos.x, y: Math.max(14, player.pos.y + 6), z: player.pos.z + 34 },
      mode: "stalk",
      modeTimer: 0,
      trailDistance: 32,
      chaseLerp: 4.2,
      chaseLerpZ: 4.4,
      swayFreq: 2.0,
      swayAmp: 5.5,
      stalkDuration: 3.2,
      burstDelay: 0.52,
      burstsFired: 0,
      maxBursts: 3,
      boostSpeed: 240,
      exitLead: 170,
      exitX,
      exitY: 28,
      fireInterval: 0.48,
      fireCooldown: 0.36,
      hp: 140,
      maxHp: 140,
      hitRadius: 12,
      shotDamage: 16,
      hitFlash: 0,
    };
    enemyObjects.push(chaser);
  }

  function initSpaceScene() {
    spaceScene.objects.length = 0;
    spaceScene.rings.length = 0;
    spaceScene.walkers.length = 0;
    spaceScene.corridors.length = 0;
    spaceScene.guideBeacons.length = 0;
    spaceScene.stars = generateStarField(220, 3600, player.pos.z - 2000);
    const layers = [
      { count: 8, radius: 42, height: 86, depth: -2600 },
      { count: 10, radius: 64, height: 120, depth: -3000 },
      { count: 12, radius: 90, height: 160, depth: -3400 },
    ];
    for (const layer of layers) {
      for (let i = 0; i < layer.count; i++) {
        const angle = (i / layer.count) * Math.PI * 2 + Math.random() * 0.2;
        const r = layer.radius + Math.random() * 12 - 6;
        const x = Math.cos(angle) * r;
        const z = layer.depth - Math.sin(angle) * r * 1.6;
        const y = layer.height + Math.sin(angle * 2) * 12;
        const scale = 1.2 + Math.random() * 0.8;
        const cluster = createAsteroidCluster(x, y, z, scale);
        spaceScene.objects.push({
          type: "asteroid",
          center: { x, y, z },
          radius: 9 * scale,
          edges: edgesToFloat32(cluster),
        });
      }
    }
    const corridorStart = -2600;
    const corridorLength = 2200;
    const corridorEdges = edgesToFloat32(createSpaceCorridor(0, 148, corridorStart, corridorLength, 20, 26));
    spaceScene.corridors.push({ type: "corridor", edges: corridorEdges });
    for (let i = 0; i < 6; i++) {
      const offset = (i / 5) * corridorLength;
      const baseZ = corridorStart - offset - 120;
      const offsetX = (Math.random() * 2 - 1) * 52;
      const offsetY = 150 + Math.random() * 50;
      const scale = 1.8 + Math.random() * 1.6;
      const clusterA = createAsteroidCluster(offsetX, offsetY, baseZ, scale);
      spaceScene.objects.push({
        type: "asteroid",
        center: { x: offsetX, y: offsetY, z: baseZ },
        radius: 9 * scale,
        edges: edgesToFloat32(clusterA),
      });
      const offsetX2 = offsetX * -0.6;
      const offsetY2 = offsetY - 24;
      const baseZ2 = baseZ - 60;
      const scale2 = scale * 0.8;
      const clusterB = createAsteroidCluster(offsetX2, offsetY2, baseZ2, scale2);
      spaceScene.objects.push({
        type: "asteroid",
        center: { x: offsetX2, y: offsetY2, z: baseZ2 },
        radius: 9 * scale2,
        edges: edgesToFloat32(clusterB),
      });
    }
    const beaconCount = 14;
    for (let i = 0; i <= beaconCount; i++) {
      const t = i / beaconCount;
      const z = corridorStart - corridorLength * t;
      const sway = Math.sin(t * Math.PI * 1.5) * 6;
      spaceScene.guideBeacons.push({
        x: sway * 0.4,
        y: 150 + Math.sin(t * Math.PI) * 18,
        z,
        phase: Math.random() * Math.PI * 2,
      });
    }
    const ringEdges = edgesToFloat32(createAsteroidRingEdges(0, 140, -3000, 52, 12, 32));
    spaceScene.rings.push({ type: "ring", edges: ringEdges });
  }

  function initSpaceEnemies() {
    enemyObjects.length = 0;
    const ambushPositions = [-2800, -3100, -3320, -3600];
    ambushPositions.forEach((z, idx) => {
      const side = idx % 2 === 0 ? -1 : 1;
      const base = { x: side * 26, y: 160 + Math.random() * 18, z };
      const enemy = {
        type: "ambush",
        shape: enemyFighterShape,
        base,
        home: { ...base },
        amplitudeX: 8,
        amplitudeY: 5,
        frequency: 0.8 + Math.random() * 0.5,
        phase: Math.random() * Math.PI * 2,
        hp: 120,
        maxHp: 120,
        hitRadius: 12,
        fireInterval: 1.4 + Math.random() * 0.5,
        fireCooldown: 0.6 + Math.random() * 0.6,
      };
      maybeAssignShieldCarrier(enemy, 0.18);
      enemyObjects.push(enemy);
    });
    const walkerAnchors = [
      { x: -34, y: 168, z: -2950 },
      { x: 28, y: 180, z: -3220 },
      { x: -12, y: 192, z: -3480 },
    ];
    walkerAnchors.forEach((anchor, idx) => {
      const radius = 9 + Math.random() * 4;
      spaceScene.walkers.push({ ...anchor, radius });
      spaceScene.objects.push({
        type: "platform",
        edges: edgesToFloat32(createBoxEdges(anchor.x, anchor.y - 2.4, anchor.z, radius * 2.6, 2.6, radius * 2.6)),
      });
      const phase = Math.random() * Math.PI * 2;
      const startX = anchor.x + Math.cos(phase) * radius;
      const startZ = anchor.z + Math.sin(phase) * radius;
      const walker = {
        type: "walker",
        shape: enemyRobotShape,
        orbitCenter: { ...anchor },
        base: { x: startX, y: anchor.y, z: startZ },
        orbitSpeed: 0.6 + idx * 0.12,
        walkPhase: phase,
        orbitRadius: radius,
        hp: 150,
        maxHp: 150,
        hitRadius: 14,
        fireInterval: 1.8 + Math.random() * 0.3,
        fireCooldown: Math.random() * 1.4,
      };
      maybeAssignShieldCarrier(walker, 0.12);
      enemyObjects.push(walker);
    });
    const interceptors = [-2880, -3160, -3420, -3740];
    interceptors.forEach((z, idx) => {
      const offsetX = (idx % 2 === 0 ? -1 : 1) * (14 + idx * 2);
      const base = { x: offsetX, y: 184, z };
      const interceptor = {
        type: "spaceAir",
        shape: enemyFighterShape,
        base,
        home: { ...base },
        amplitudeX: 12,
        amplitudeY: 8,
        frequency: 1.3 + idx * 0.18,
        phase: Math.random() * Math.PI * 2,
        speed: 240,
        hp: 110,
        maxHp: 110,
        hitRadius: 11,
        fireInterval: 1.0 + Math.random() * 0.4,
        fireCooldown: Math.random() * 0.8,
      };
      maybeAssignShieldCarrier(interceptor, 0.2);
      enemyObjects.push(interceptor);
    });
    const corridorGuards = 12;
    for (let i = 0; i < corridorGuards; i++) {
      const lane = (i % 3 - 1) * 18 + (Math.random() * 6 - 3);
      const baseZ = -2700 - i * 150;
      const base = { x: lane, y: 172 + Math.random() * 14, z: baseZ };
      const guard = {
        type: "corridorGuard",
        shape: enemyFighterShape,
        base,
        home: { ...base },
        laneX: lane,
        bobAmp: 10 + Math.random() * 6,
        speed: 220 + Math.random() * 40,
        frequency: 1.1 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2,
        hp: 140,
        maxHp: 140,
        hitRadius: 13,
        fireInterval: 0.9 + Math.random() * 0.4,
        fireCooldown: 0.4 + Math.random() * 0.6,
      };
      maybeAssignShieldCarrier(guard, 0.15);
      enemyObjects.push(guard);
    }
  }

  initStage0Scene();
  initCity();

  // === ウインドウリサイズ対応 ===
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(window.innerWidth * dpr);
    canvas.height = Math.round(window.innerHeight * dpr);
    canvas.style.width = "100vw";
    canvas.style.height = "100vh";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // === ビルの再配置（エンドレス化） ===
  function recycleCityObjects() {
    for (const obj of cityObjects) {
      if (obj.type === "ground" || obj.type === "gate") continue;
      const worldZ = obj.position ? obj.position.z : obj.zOrigin;
      if (worldZ > player.pos.z + 120) {
        const move = 2400;
        if (obj.position) obj.position.z -= move;
        if (obj.edges) {
          for (const edge of obj.edges) {
            edge[0].z -= move;
            edge[1].z -= move;
          }
        }
      }
    }
  }

  function updateEnemies(dt) {
    if (stageClear) return;
    for (let i = enemyObjects.length - 1; i >= 0; i--) {
      const enemy = enemyObjects[i];
      if (!enemy) continue;
      if (enemy.hitFlash) {
        enemy.hitFlash = Math.max(0, enemy.hitFlash - dt * 2.4);
      }
      if (enemy.type === "air" || enemy.type === "ground") {
        if (enemy.base.z > player.pos.z + 140) {
          enemy.base.z -= 2400;
          enemy.pathCenterX = (Math.random() * 2 - 1) * 26;
          enemy.phase = Math.random() * Math.PI * 2;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "incoming") {
        enemy.base.z += (enemy.speed || 200) * dt;
        if (enemy.base.z > player.pos.z + 100) {
          const reset = enemy.resetDistance || 1200;
          const offsetZ = enemy.formationOffset ? enemy.formationOffset.z : 0;
          enemy.base.z = player.pos.z - reset + offsetZ;
          enemy.pathCenterX = (enemy.originalX || 0) + (Math.random() * 2 - 1) * 4;
          enemy.phase = Math.random() * Math.PI * 2;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "pursuer") {
        const lerp = Math.min(1, dt * (enemy.chaseLerp || 3.0));
        const targetX = clamp(player.pos.x + Math.sin(simTime * (enemy.swayFreq || 1.6)) * (enemy.swayAmp || 5), -30, 30);
        const targetY = clamp(player.pos.y + 4, 6, 26);
        enemy.base.x += (targetX - enemy.base.x) * lerp;
        enemy.base.y += (targetY - enemy.base.y) * lerp;
        const lerpZ = Math.min(1, dt * (enemy.chaseLerpZ || 2.0));
        const targetZ = player.pos.z + (enemy.trailDistance || 24);
        enemy.base.z += (targetZ - enemy.base.z) * lerpZ;
      } else if (enemy.type === "chaseAce") {
        enemy.modeTimer = (enemy.modeTimer || 0) + dt;
        const lateralWave = Math.sin(simTime * (enemy.swayFreq || 2.0)) * (enemy.swayAmp || 5.5);
        const targetX = clamp(player.pos.x + lateralWave, -34, 34);
        const targetY = clamp(player.pos.y + 5, 10, 32);
        if (enemy.mode !== "boost") {
          const lerp = Math.min(1, dt * (enemy.chaseLerp || 4.0));
          enemy.base.x += (targetX - enemy.base.x) * lerp;
          enemy.base.y += (targetY - enemy.base.y) * Math.min(1, dt * 3.2);
          const lerpZ = Math.min(1, dt * (enemy.chaseLerpZ || 4.4));
          const targetZ = player.pos.z + (enemy.trailDistance || 30);
          enemy.base.z += (targetZ - enemy.base.z) * lerpZ;
          if ((enemy.modeTimer || 0) > (enemy.stalkDuration || 3.0)) {
            enemy.mode = "boost";
            enemy.modeTimer = 0;
            enemy.fireInterval = 0;
            enemy.fireCooldown = Number.POSITIVE_INFINITY;
          }
        } else {
          const exitX = enemy.exitX ?? targetX;
          const exitY = enemy.exitY ?? 24;
          enemy.base.x += (exitX - enemy.base.x) * Math.min(1, dt * 2.0);
          enemy.base.y += (exitY - enemy.base.y) * Math.min(1, dt * 1.6);
          enemy.base.z -= (enemy.boostSpeed || 240) * dt;
          if (player.pos.z - enemy.base.z > (enemy.exitLead || 160)) {
            enemyObjects.splice(i, 1);
            continue;
          }
        }
      } else if (enemy.type === "ambush") {
        const home = enemy.home || enemy.base;
        const freq = enemy.frequency || 1.0;
        const wave = Math.sin(simTime * freq + (enemy.phase || 0));
        const sway = Math.cos(simTime * freq * 0.6 + (enemy.phase || 0));
        enemy.base.x = clamp((home.x || 0) + wave * (enemy.amplitudeX || 0), -80, 80);
        enemy.base.y = (home.y || 140) + sway * (enemy.amplitudeY || 0);
        if (player.pos.z - enemy.base.z < 220) {
          enemy.base.z -= dt * 110;
        }
      } else if (enemy.type === "spaceAir") {
        const home = enemy.home || enemy.base;
        const freq = enemy.frequency || 1.0;
        const wave = Math.sin(simTime * freq + (enemy.phase || 0));
        const sway = Math.cos(simTime * freq * 0.8 + (enemy.phase || 0));
        enemy.base.x = clamp((home.x || 0) + wave * (enemy.amplitudeX || 0), -90, 90);
        enemy.base.y = (home.y || 150) + sway * (enemy.amplitudeY || 0);
        enemy.base.z += (enemy.speed || 240) * dt;
        if (enemy.base.z > player.pos.z + 120) {
          enemy.base.z = player.pos.z - 900 - Math.random() * 260;
          if (enemy.home) enemy.home.z = enemy.base.z;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "corridorGuard") {
        const lane = enemy.laneX || 0;
        const bob = enemy.bobAmp || 10;
        const freq = enemy.frequency || 1.0;
        enemy.phase = (enemy.phase || 0) + dt * freq;
        const guide = spaceScene.guidePhase || 0;
        enemy.base.x = clamp(lane + Math.sin(enemy.phase) * 4.5, -72, 72);
        enemy.base.y = ((enemy.home && enemy.home.y) || 172) + Math.sin(guide + enemy.phase) * bob;
        enemy.base.z += (enemy.speed || 240) * dt;
        if (enemy.base.z > player.pos.z + 140) {
          enemy.base.z = player.pos.z - 880 - Math.random() * 220;
          if (enemy.home) enemy.home.z = enemy.base.z;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "walker") {
        enemy.walkPhase = (enemy.walkPhase || 0) + dt * (enemy.orbitSpeed || 0.8);
        const radius = enemy.orbitRadius || 10;
        const center = enemy.orbitCenter || enemy.base;
        enemy.base.x = center.x + Math.cos(enemy.walkPhase) * radius;
        enemy.base.z = center.z + Math.sin(enemy.walkPhase) * radius;
        enemy.base.y = center.y + Math.sin(enemy.walkPhase * 2) * 1.4;
      }
      if (enemy.fireInterval) {
        enemy.fireCooldown = (enemy.fireCooldown ?? enemy.fireInterval) - dt;
        if (enemy.fireCooldown <= 0) {
          const pose = getEnemyPose(enemy);
          if (pose) {
            const dz = player.pos.z - pose.z;
            let canFire = false;
            if (enemy.type === "ground") {
              canFire = dz > 10 && dz < 320;
            } else if (enemy.type === "pursuer") {
              canFire = dz > 12 && dz < 140;
            } else {
              canFire = dz > 20 && dz < 720;
            }
            if (canFire) {
              spawnEnemyShot(enemy);
              if (enemy.type === "chaseAce") {
                enemy.burstsFired = (enemy.burstsFired || 0) + 1;
                const remaining = (enemy.maxBursts || 3) - enemy.burstsFired;
                if (remaining <= 0) {
                  enemy.mode = "boost";
                  enemy.modeTimer = 0;
                  enemy.fireInterval = 0;
                  enemy.fireCooldown = Number.POSITIVE_INFINITY;
                } else {
                  enemy.fireCooldown += enemy.burstDelay || enemy.fireInterval || 0.5;
                }
              } else {
                enemy.fireCooldown += enemy.fireInterval;
              }
            } else {
              enemy.fireCooldown += Math.max(0.4, enemy.fireInterval * 0.5);
            }
          } else {
            enemy.fireCooldown = enemy.fireInterval;
          }
        }
      }
    }
  }

  // === 自機のワイヤーフレーム ===
  function getPlayerEdges() {
    const wingSpan = 18;
    const noseZ = player.pos.z - 16;
    const tailZ = player.pos.z + 4;
    const centerY = player.pos.y;
    const rawEdges = [
      // 主翼ライン
      [
        { x: player.pos.x - wingSpan * 0.5, y: centerY, z: player.pos.z - 4 },
        { x: player.pos.x + wingSpan * 0.5, y: centerY, z: player.pos.z - 4 },
      ],
      // 機首
      [
        { x: player.pos.x - 2, y: centerY, z: player.pos.z - 4 },
        { x: player.pos.x, y: centerY - 2, z: noseZ },
      ],
      [
        { x: player.pos.x + 2, y: centerY, z: player.pos.z - 4 },
        { x: player.pos.x, y: centerY - 2, z: noseZ },
      ],
      // 胴体上部
      [
        { x: player.pos.x, y: centerY - 2, z: noseZ },
        { x: player.pos.x, y: centerY + 2, z: tailZ },
      ],
      // 垂直尾翼
      [
        { x: player.pos.x, y: centerY + 2, z: tailZ },
        { x: player.pos.x, y: centerY + 6, z: tailZ + 4 },
      ],
      [
        { x: player.pos.x, y: centerY + 2, z: player.pos.z - 4 },
        { x: player.pos.x, y: centerY + 6, z: tailZ },
      ],
    ];
    const cosR = Math.cos(player.roll);
    const sinR = Math.sin(player.roll);
    const rotated = rawEdges.map(([a, b]) => {
      const arx = (a.x - player.pos.x) * cosR - (a.y - centerY) * sinR + player.pos.x;
      const ary = (a.x - player.pos.x) * sinR + (a.y - centerY) * cosR + centerY;
      const brx = (b.x - player.pos.x) * cosR - (b.y - centerY) * sinR + player.pos.x;
      const bry = (b.x - player.pos.x) * sinR + (b.y - centerY) * cosR + centerY;
      return [
        { x: arx, y: ary, z: a.z },
        { x: brx, y: bry, z: b.z },
      ];
    });
    return rotated;
  }

  // === メインループ ===
  let prevTime = performance.now();
  
  // サウンドテストモードを初期化
  initSoundTestMode();
  initAIPanelLoop();
  
  function loop(now) {
    const dt = Math.min(0.05, (now - prevTime) / 1000);
    prevTime = now;

    update(dt);
    render();
    updateAIPanelGuideVisibility();

    requestAnimationFrame(loop);
  }

  // === 自機とカメラの更新 ===
  function update(dt) {
    simTime += dt;
    player.invuln = Math.max(0, player.invuln - dt);
    advanceShieldFixBanner(dt);
    if (gamePhase === "soundTest") {
      // サウンドテストモードでは何も更新しない
      return;
    }
    if (gamePhase === "stage0") {
      phaseTime += dt;
      updateStage0(dt);
      return;
    }
    if (gamePhase === "gameOver") {
      phaseTime += dt;
      updateGameOver(dt);
      return;
    }
    if (gamePhase === "cityExit") {
      phaseTime += dt;
      updateCityExit(dt);
      return;
    }
    if (gamePhase === "stage2") {
      phaseTime += dt;
      updateStage2(dt);
      return;
    }
    if (gamePhase === "finalBoss") {
      phaseTime += dt;
      updateFinalBossStage(dt);
      return;
    }
    if (gamePhase === "finalClear") {
      phaseTime += dt;
      updateFinalClear(dt);
      return;
    }

    phaseTime += dt;
    updateStage1(dt);
  }

  function updateStage1(dt) {
    if (stage1MusicPending && !stage1MusicActive) {
      // ユーザー操作後にBGMを確実に再開
      tryPlayStage1Music();
    }
    const lateralSpeed = 160;   // スペースハリアー風の俊敏な横移動速度
    const verticalSpeed = 150;  // 同じく縦方向の移動速度
    const boundsX = 32;
    const boundsY = 38; // スペースハリアー風に縦方向の可動域を広げて画面上部へも追い込めるように

    if (!stage1Events.chaseSpawned && player.pos.z < -320) {
      spawnStage1ChaseEnemy();
      stage1Events.chaseSpawned = true;
    }

    let inputX = 0;
    let inputY = 0;
    if (keys.has("ArrowLeft") || keys.has("KeyA")) inputX -= 1;
    if (keys.has("ArrowRight") || keys.has("KeyD")) inputX += 1;
    if (keys.has("ArrowUp") || keys.has("KeyW")) inputY -= 1;
    if (keys.has("ArrowDown") || keys.has("KeyS")) inputY += 1;

    // スペースハリアーのようにキー入力を即座に反映してクイックに位置決定
    const deltaX = inputX * lateralSpeed * dt;
    const deltaY = inputY * verticalSpeed * dt;
    player.pos.x = clamp(player.pos.x + deltaX, -boundsX, boundsX);
    player.pos.y = clamp(player.pos.y + deltaY, 2, boundsY);
    player.vel.x = deltaX / Math.max(dt, 1e-4);
    player.vel.y = deltaY / Math.max(dt, 1e-4);
    let forwardSpeed = player.speedForward;
    if (boss.active && !boss.destroyed) {
      forwardSpeed = 0;
    }
    player.pos.z -= forwardSpeed * dt;
    if (boss.active && !boss.destroyed) {
      const distance = player.pos.z - boss.pos.z;
      const clamped = clamp(distance, bossDistanceConstraint.min, bossDistanceConstraint.max);
      const targetZ = boss.pos.z + clamped;
      const followRate = Math.min(1, dt * 3.8);
      player.pos.z += (targetZ - player.pos.z) * followRate;
    }

    player.roll = 0; // ロールを廃してスペースハリアー特有の平行移動に統一
    updatePlayerRolling(dt);

    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 9);
    camera.pos.y += (player.pos.y + 6 - camera.pos.y) * Math.min(1, dt * 6);
    camera.pos.z = player.pos.z + 40;

    environment = "city";
    skyMix = Math.max(0, skyMix - dt * 0.25);

    checkCityCollisions();
    updateShieldPickups(dt);

    recycleCityObjects();
    updateEnemies(dt);
    updateBoss(dt);
    updatePlayerWeapons(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  // === シティ撃破後の上昇シーケンス ===
  function updateCityExit(dt) {
    environment = cityExitState.progress < 0.75 ? "city" : "space";
    const accelDecay = Math.pow(0.22, dt * 60);
    player.vel.x *= accelDecay;
    player.vel.y *= accelDecay;
    const prevProg = cityExitState.progress;
    cityExitState.progress = Math.min(1, cityExitState.progress + dt / cityExitState.duration);
    const t = cityExitState.progress;
    updateCityExitStreaks(dt, t);
    const speedBoost = 0.9 + t * 0.35;
    player.pos.z -= player.speedForward * speedBoost * dt;
    if (!cityExitState.passed && player.pos.z <= boss.pos.z - 160) {
      cityExitState.passed = true;
    }
    const climbStart = 0.35;
    const climb = smoothstep((t - climbStart) / Math.max(0.0001, 1 - climbStart));
    const targetY = stage0State.targetY + 220 + climb * 340;
    player.pos.y += (targetY - player.pos.y) * Math.min(1, dt * 1.6);
    player.pos.x *= Math.pow(0.6, dt * 60);
    player.roll *= Math.pow(0.18, dt * 60);
    updatePlayerRolling(dt);

    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 1.4);
    camera.pos.y = player.pos.y + 16 - climb * 6;
    camera.pos.z = player.pos.z + 36 - climb * 32;

    skyMix = Math.min(1, skyMix + dt * 0.5 + t * 0.12);

    spaceScene.guidePhase = (spaceScene.guidePhase + dt * 1.8) % (Math.PI * 2);
    animateStars(dt);
    updateShieldPickups(dt);
    updateProjectiles(dt);
    updateExplosions(dt);

    // 宇宙上昇効果音（上昇開始時に一度だけ再生）
    if (climb > 0.01 && !cityExitState.ascentSfxPlayed) {
      triggerSpaceAscentSfx(climb);
      cityExitState.ascentSfxPlayed = true;
    }

    if (prevProg < 1 && cityExitState.progress >= 1) {
      startSpaceStage();
    }
  }

  // === 宇宙ステージ初期化 ===
  function startSpaceStage() {
    cityExitState.progress = 0;
    cityExitState.passed = false;
    cityExitState.ascentSfxPlayed = false;
    cityExitState.streaks.length = 0;
    stopStageMusic();
    environment = "space";
    skyMix = 1;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    player.pos.y = Math.max(player.pos.y, 240);
    player.pos.z = -1800;
    camera.pos.x = player.pos.x;
    camera.pos.y = player.pos.y + 18;
    camera.pos.z = player.pos.z + 60;
    missilesRemaining = MISSILE_STOCK_MAX;
    enemyShots.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    explosions.length = 0;
    shieldPickups.length = 0;
    resetPlayerVitals(false);
    player.shield = player.maxShield; // 宇宙突入時にシールドを再充填
    player.invuln = 1.2;
    spaceScene.waveTimer = 0;
    initSpaceScene();
    initSpaceEnemies();
    spaceScene.guidePhase = 0;
    setupSpaceBattleship();
    gamePhase = "stage2";
    phaseTime = 0;
    queueStage2Music();
  }

  function scheduleFinalBossStage(delay = 3.0) {
    // 最終ボス戦への移行を遅延予約
    finalBossQueued = true;
    finalBossCountdown = delay;
  }

  function startFinalBossStage(skipFullRestore = false) {
    // 最終ボス戦の空間とステータスを初期化
    setupFinalBoss();
    stopStageMusic();
    const desiredDistance = finalBossDistanceConstraint.max - 40;
    player.pos.x = 0;
    player.pos.y = 240;
    player.pos.z = boss.pos.z + desiredDistance;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    resetPlayerVitals(skipFullRestore);
    player.shield = player.maxShield;
    player.invuln = 1.2;
    missilesRemaining = MISSILE_STOCK_MAX;
    enemyObjects.length = 0;
    enemyShots.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    explosions.length = 0;
    shieldPickups.length = 0;
    spaceScene.waveTimer = 0;
    spaceScene.waveInterval = 8.0;
    if (!spaceScene.stars.length) {
      initSpaceScene();
    }
    spaceScene.objects.length = 0;
    spaceScene.rings.length = 0;
    spaceScene.walkers.length = 0;
    spaceScene.corridors.length = 0;
    spaceScene.guideBeacons.length = 0;
    if (spaceScene.stars.length) {
      spaceScene.stars.forEach((star) => {
        star.z = player.pos.z - 400 - Math.random() * 2600;
      });
    }
    environment = "space";
    skyMix = 1;
    camera.pos.x = player.pos.x;
    camera.pos.y = player.pos.y + 26;
    camera.pos.z = player.pos.z + 60;
    boss.active = true;
    boss.fireCooldown = 2.4;
    boss.suctionCooldown = 3.0;
    boss.suctionActive = false;
    boss.suctionProgress = 0;
    phaseTime = 0;
    stageClear = false;
    finalBossQueued = false;
    finalBossCountdown = 0;
    gamePhase = "finalBoss";
    queueStage3Music();
  }

  function startFinalBossTest() {
    // テストモードから最終ボス戦へ直接遷移
    startFinalBossStage(true);
  }

  function prepareFinalBossTransition() {
    // 戦艦撃破後の間を設けて最終ボス戦を起動
    scheduleFinalBossStage(3.2);
    stageClear = false;
    enemyObjects.length = 0;
    enemyShots.length = 0;
    shieldPickups.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    stopStageMusic();
  }

  // === 宇宙ステージの更新 ===
  function updateStage2(dt) {
    environment = "space";
    skyMix = Math.min(1, skyMix + dt * 0.35);
    const lateralSpeed = 180;
    const verticalSpeed = 190;
    const boundsX = 48;
    const boundsY = 210;
    const minAltitude = 32 + Math.min(1, skyMix) * 18; // 上空への逃げ場を確保しつつ下限は低めに維持

    let inputX = 0;
    let inputY = 0;
    if (keys.has("ArrowLeft") || keys.has("KeyA")) inputX -= 1;
    if (keys.has("ArrowRight") || keys.has("KeyD")) inputX += 1;
    if (keys.has("ArrowUp") || keys.has("KeyW")) inputY -= 1;
    if (keys.has("ArrowDown") || keys.has("KeyS")) inputY += 1;

    // 宇宙空間でもハリアー風の即応移動を適用
    const deltaX = inputX * lateralSpeed * dt;
    const deltaY = inputY * verticalSpeed * dt;
    player.pos.x = clamp(player.pos.x + deltaX, -boundsX, boundsX);
    player.pos.y = clamp(player.pos.y + deltaY, minAltitude, boundsY);
    player.vel.x = deltaX / Math.max(dt, 1e-4);
    player.vel.y = deltaY / Math.max(dt, 1e-4);

    let forwardSpeed = player.speedForward * 1.25;
    if (boss.active && !boss.destroyed && boss.variant === "battleship") {
      forwardSpeed = player.speedForward * 0.7;
    }
    player.pos.z -= forwardSpeed * dt;
    if (boss.active && !boss.destroyed && boss.variant === "battleship") {
      const distance = player.pos.z - boss.pos.z;
      const clamped = clamp(distance, battleshipDistanceConstraint.min, battleshipDistanceConstraint.max);
      const targetZ = boss.pos.z + clamped;
      player.pos.z += (targetZ - player.pos.z) * Math.min(1, dt * 2.8);
    }

    player.roll = 0;
    updatePlayerRolling(dt);

    checkSpaceCollisions();
    updateShieldPickups(dt);

    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 8);
    camera.pos.y += (player.pos.y + 10 - camera.pos.y) * Math.min(1, dt * 5);
    camera.pos.z = player.pos.z + 52;

    spaceScene.waveTimer += dt;
    spaceScene.guidePhase = (spaceScene.guidePhase + dt * 2.2) % (Math.PI * 2);
    animateStars(dt);
    updateEnemies(dt);
    updateBoss(dt);
    updatePlayerWeapons(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
    if (finalBossQueued) {
      finalBossCountdown -= dt;
      if (finalBossCountdown <= 0) {
        finalBossQueued = false;
        startFinalBossStage(false);
        return;
      }
    }
  }

  function updateFinalBossStage(dt) {
    environment = "space";
    skyMix = 1;
    const lateralSpeed = 200;
    const verticalSpeed = 210;
    const boundsX = 52;
    const boundsY = 260;
    const minAltitude = 140;

    let inputX = 0;
    let inputY = 0;
    if (keys.has("ArrowLeft") || keys.has("KeyA")) inputX -= 1;
    if (keys.has("ArrowRight") || keys.has("KeyD")) inputX += 1;
    if (keys.has("ArrowUp") || keys.has("KeyW")) inputY -= 1;
    if (keys.has("ArrowDown") || keys.has("KeyS")) inputY += 1;

    const deltaX = inputX * lateralSpeed * dt;
    const deltaY = inputY * verticalSpeed * dt;
    player.pos.x = clamp(player.pos.x + deltaX, -boundsX, boundsX);
    player.pos.y = clamp(player.pos.y + deltaY, minAltitude, boundsY);
    player.vel.x = deltaX / Math.max(dt, 1e-4);
    player.vel.y = deltaY / Math.max(dt, 1e-4);

    if (boss.active && !boss.destroyed) {
      const distance = player.pos.z - boss.pos.z;
      const minDist = boss.chargeActive ? finalBossChargeConstraint.min : finalBossDistanceConstraint.min;
      const maxDist = boss.chargeActive ? finalBossChargeConstraint.max : finalBossDistanceConstraint.max;
      const clamped = clamp(distance, minDist, maxDist);
      const targetZ = boss.pos.z + clamped;
      player.pos.z += (targetZ - player.pos.z) * Math.min(1, dt * 3.4);
    } else {
      player.pos.z -= player.speedForward * 0.6 * dt;
    }

    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 7);
    camera.pos.y += (player.pos.y + 16 - camera.pos.y) * Math.min(1, dt * 4.6);
    camera.pos.z += (player.pos.z + 56 - camera.pos.z) * Math.min(1, dt * 3.4);
    updatePlayerRolling(dt);

    if (boss.suctionActive) {
      camera.shake = Math.max(camera.shake, 1.2 + boss.suctionProgress * 0.6);
    }
    if (boss.chargeActive) {
      camera.shake = Math.max(camera.shake, 0.8 + boss.chargeProgress * 1.2);
    }

    animateStars(dt);
    updateBoss(dt);
    updatePlayerWeapons(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  // === 最終クリア演出 ===
  function updateFinalClear(dt) {
    environment = "space";
    skyMix = 1;
    player.vel.x *= Math.pow(0.2, dt * 60);
    player.vel.y *= Math.pow(0.2, dt * 60);
    player.pos.z -= player.speedForward * 0.8 * dt;
    player.pos.y += dt * 32;
    player.roll *= Math.pow(0.2, dt * 60);
    updatePlayerRolling(dt);
    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 0.8);
    camera.pos.y = player.pos.y + 14;
    camera.pos.z = player.pos.z + 68;
    animateStars(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  function updateGameOver(dt) {
    skyMix = Math.max(0, skyMix - dt * 0.3);
    player.vel.x *= Math.pow(0.12, dt * 60);
    player.vel.y *= Math.pow(0.12, dt * 60);
    player.pos.z -= player.speedForward * 0.25 * dt;
    player.roll *= Math.pow(0.2, dt * 60);
    updatePlayerRolling(dt);
    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 0.9);
    camera.pos.y += (player.pos.y + 8 - camera.pos.y) * Math.min(1, dt * 0.9);
    camera.pos.z += (player.pos.z + 44 - camera.pos.z) * Math.min(1, dt * 1.1);
    animateStars(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  // === 星パーティクルの更新 ===
  function animateStars(dt) {
    if (!spaceScene.stars.length) return;
    const parallax = player.speedForward * 0.85;
    for (const star of spaceScene.stars) {
      star.twinkle = (star.twinkle + dt * 2.6) % (Math.PI * 2);
      star.z -= parallax * dt;
      if (star.z > player.pos.z - 200) {
        star.z = player.pos.z - 2000 - Math.random() * 3200;
        star.x = (Math.random() * 2 - 1) * 260;
        star.y = Math.random() * 240 + 40;
      }
    }
  }

  // === 描画 ===
  function render() {
    ctx.fillStyle = "#020818";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (skyMix > 0.01) {
      ctx.fillStyle = `rgba(0, 12, 40, ${Math.min(1, skyMix * 0.9)})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    drawStars(skyMix);
    drawCityExitBackdrop();

    const hpText = `HP ${Math.max(0, Math.round(player.hp))}/${player.maxHp}`;
    const shieldText = `SHIELD ${Math.max(0, Math.round(player.shield))}`;
    const stockText = `STOCK ${player.stocks}/${player.maxStocks}`;
    const vitalsText = `${hpText} / ${shieldText} / ${stockText}`;
    const missileText = Number.isFinite(MISSILE_STOCK_MAX)
      ? `MISSILES ${missilesRemaining}/${MISSILE_STOCK_MAX}`
      : "MISSILES ∞"; // 無限ストックであることをHUDに表示
    if (gamePhase === "stage0") {
      hudLabel.textContent = "LAUNCH BAY / PREP SEQUENCE";
    } else if (gamePhase === "finalBoss" && boss.variant === "finalFace" && boss.active && !boss.destroyed) {
      const suctionStatus = boss.suctionActive ? "SINGULARITY" : "STABLE FIELD";
      hudLabel.textContent = `FINAL BOSS / ${vitalsText} / ${missileText} / ${suctionStatus}`;
    } else if (stageClear) {
      hudLabel.textContent = "MISSION COMPLETE";
    } else if (gamePhase === "cityExit") {
      hudLabel.textContent = `CITY RUN / ${vitalsText} / ${missileText} / ASCENT`;
    } else if (gamePhase === "stage2" && boss.variant === "battleship" && boss.active && !boss.destroyed) {
      const waveStatus = boss.waveCharge > 0.05 ? "WAVECANNON" : `BATTLESHIP HP ${Math.max(0, boss.hp)}`;
      hudLabel.textContent = `ASTEROID RUN / ${vitalsText} / ${missileText} / ${waveStatus}`;
    } else if (gamePhase === "gameOver") {
      hudLabel.textContent = `SYSTEM FAILURE / ${vitalsText}`;
    } else if (environment === "space") {
      hudLabel.textContent = `ASTEROID RUN / ${vitalsText} / ${missileText}`;
    } else if (boss.active && !boss.destroyed) {
      hudLabel.textContent = `CITY RUN / ${vitalsText} / ${missileText} / BOSS HP ${Math.max(0, boss.hp)}`;
    } else {
      hudLabel.textContent = `CITY RUN / ${vitalsText} / ${missileText}`;
    }

    ctx.save();

    const cityFade = environment === "space" ? Math.max(0, 1 - skyMix * 1.4) : 1;
    if (cityFade > 0.02) {
      for (const obj of cityObjects) {
        if (obj.type === "ground") {
          drawEdges(obj.edges, `rgba(32, 126, 255, ${0.25 * cityFade})`, 1, `rgba(10, 66, 200, ${0.6 * cityFade})`);
        } else if (obj.type === "building") {
          drawEdges(obj.edges, `rgba(0, 123, 255, ${0.78 * cityFade})`, 1.6, `rgba(0, 123, 255, ${0.7 * cityFade})`);
        } else if (obj.type === "gate") {
          const pulse = 0.6 + Math.sin(performance.now() * 0.003) * 0.4;
          drawEdges(obj.edges, `rgba(0, 173, 255, ${Math.min(1, pulse) * cityFade})`, 2.2, `rgba(0, 140, 255, ${0.9 * cityFade})`);
        }
      }
    }

    if (skyMix > 0.08) {
      drawSpaceScenery(skyMix);
      drawGuideBeacons(skyMix);
    }

    if (gamePhase === "stage0") {
      drawStage0Hangar();
    }

    // ボス描画
    const bossGroups = getBossEdgeGroups();
    if (bossGroups) {
      if (bossGroups.variant === "battleship") {
        drawEdges(bossGroups.engines.edges, "rgba(0, 120, 255, 0.6)", 2.6, "rgba(0, 150, 255, 0.6)", bossGroups.engines.transform);
        drawEdges(bossGroups.fins.edges, "rgba(0, 160, 255, 0.65)", 2.4, "rgba(0, 190, 255, 0.65)", bossGroups.fins.transform);
        drawEdges(bossGroups.base.edges, "rgba(0, 190, 255, 0.78)", 2.8, "rgba(0, 220, 255, 0.85)", bossGroups.base.transform);
        drawEdges(bossGroups.bridge.edges, "rgba(0, 255, 255, 0.82)", 3.0, "rgba(0, 255, 230, 0.88)", bossGroups.bridge.transform);
        drawEdges(bossGroups.cannon.edges, "rgba(0, 255, 220, 0.95)", 3.6, "rgba(0, 255, 200, 0.92)", bossGroups.cannon.transform);
        drawEdges(bossGroups.antenna.edges, "rgba(160, 255, 255, 0.8)", 2.2, "rgba(120, 220, 255, 0.82)", bossGroups.antenna.transform);
      } else if (bossGroups.variant === "tank") {
        drawEdges(bossGroups.treads.edges, "rgba(0, 70, 160, 0.85)", 2.4, "rgba(0, 70, 220, 0.8)", bossGroups.treads.transform);
        drawEdges(bossGroups.base.edges, "rgba(0, 120, 220, 0.9)", 2.8, "rgba(0, 120, 255, 0.9)", bossGroups.base.transform);
        drawEdges(bossGroups.hull.edges, "rgba(0, 150, 255, 0.95)", 2.6, "rgba(0, 160, 255, 0.9)", bossGroups.hull.transform);
        drawEdges(bossGroups.turret.edges, "rgba(0, 200, 255, 0.95)", 3.0, "rgba(0, 220, 255, 0.9)", bossGroups.turret.transform);
        drawEdges(bossGroups.cannon.edges, "rgba(0, 255, 230, 0.95)", 3.2, "rgba(0, 255, 200, 0.9)", bossGroups.cannon.transform);
        drawEdges(bossGroups.antenna.edges, "rgba(0, 255, 255, 0.9)", 2.2, "rgba(0, 255, 255, 0.8)", bossGroups.antenna.transform);
      } else if (bossGroups.variant === "finalFace") {
        drawEdges(bossGroups.outline.edges, "rgba(0, 210, 255, 0.92)", 3.6, "rgba(0, 160, 255, 0.85)", bossGroups.outline.transform);
        drawEdges(bossGroups.crown.edges, "rgba(0, 255, 240, 0.88)", 3.0, "rgba(0, 200, 255, 0.82)", bossGroups.crown.transform);
        drawEdges(bossGroups.eyes.edges, "rgba(0, 255, 255, 0.95)", 3.2, "rgba(0, 200, 255, 0.88)", bossGroups.eyes.transform);
        drawEdges(bossGroups.nose.edges, "rgba(0, 200, 255, 0.9)", 2.6, "rgba(0, 140, 255, 0.82)", bossGroups.nose.transform);
        drawEdges(bossGroups.mouth.edges, "rgba(0, 170, 255, 0.9)", 3.4, "rgba(0, 120, 255, 0.8)", bossGroups.mouth.transform);
        if (boss.suctionActive && boss.suctionProgress > 0) {
          const haloAlpha = 0.25 + boss.suctionProgress * 0.35;
          ctx.strokeStyle = `rgba(0, 255, 255, ${haloAlpha})`;
          ctx.shadowColor = `rgba(0, 200, 255, ${haloAlpha})`;
          ctx.shadowBlur = 24 * haloAlpha;
          ctx.lineWidth = 4.2;
          const halo = bossLocalToWorld(0, -18, -80);
          const proj = projectPoint(halo);
          if (proj) {
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, 46 + boss.suctionProgress * 14, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.shadowBlur = 0;
        }
        if (boss.laughTimer > 0) {
          const laughPhase = clamp(1 - boss.laughTimer / 1.6, 0, 1);
          const cycles = 3.2;
          const wave = Math.sin(laughPhase * Math.PI * cycles);
          const mouthOpen = Math.pow(Math.max(0, wave), 1.2);
          drawFinalBossLaughMouth(mouthOpen);
        }
      }
    }

    if (boss.variant === "finalFace" && boss.active && boss.laughTimer > 0) {
      // 笑い演出のオーバーレイを中央に表示
      const laughAlpha = Math.min(1, boss.laughTimer / 1.6);
      ctx.save();
      ctx.globalAlpha = 0.8 * laughAlpha;
      ctx.fillStyle = "rgba(0, 225, 255, 0.9)";
      ctx.font = `${64 * Math.max(canvas.width / 1280, canvas.height / 720)}px \"Helvetica Neue\", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0, 120, 255, 0.7)";
      ctx.shadowBlur = 26;
      ctx.fillText("WAHAHA!!", canvas.width * 0.5, canvas.height * 0.26);
      ctx.restore();
    }

    // 敵機描画（空中・地上の両方）
    const enemyTransform = { tx: 0, ty: 0, tz: 0 }; // 使い回してGC負荷を減らす
    for (const enemy of enemyObjects) {
      const pose = getEnemyPose(enemy);
      if (!pose) continue;
      enemyTransform.tx = pose.x;
      enemyTransform.ty = pose.y;
      enemyTransform.tz = pose.z;
      const flash = enemy.hitFlash ? Math.min(1, enemy.hitFlash) : 0;
      if (enemy.type === "air") {
        drawEdges(enemy.shape, `rgba(0, 255, 210, ${0.75 + flash * 0.5})`, 2.6 + flash * 0.8, `rgba(0, 220, 210, ${0.7 + flash * 0.3})`, enemyTransform);
      } else if (enemy.type === "incoming") {
        drawEdges(enemy.shape, `rgba(0, 255, 148, ${0.75 + flash * 0.5})`, 2.8 + flash * 0.9, `rgba(0, 230, 140, ${0.75 + flash * 0.25})`, enemyTransform);
      } else if (enemy.type === "pursuer") {
        drawEdges(enemy.shape, `rgba(0, 160, 255, ${0.78 + flash * 0.5})`, 2.8 + flash * 1.0, `rgba(0, 130, 255, ${0.75 + flash * 0.3})`, enemyTransform);
      } else if (enemy.type === "walker") {
        drawEdges(enemy.shape, `rgba(0, 180, 255, ${0.74 + flash * 0.4})`, 2.2 + flash * 0.6, `rgba(0, 200, 255, ${0.7 + flash * 0.3})`, enemyTransform);
      } else if (enemy.type === "ambush" || enemy.type === "spaceAir") {
        drawEdges(enemy.shape, `rgba(0, 255, 210, ${0.7 + flash * 0.35})`, 2.6 + flash * 0.8, `rgba(0, 220, 255, ${0.68 + flash * 0.3})`, enemyTransform);
      } else {
        drawEdges(enemy.shape, `rgba(0, 90, 255, ${0.72 + flash * 0.45})`, 2.0 + flash * 0.7, `rgba(0, 80, 255, ${0.68 + flash * 0.22})`, enemyTransform);
      }
      if (enemy.dropShield) {
        // シールド補給キャリアは金色の光輪で強調表示
        drawEdges(enemy.shape, `rgba(255, 220, 0, ${0.3 + flash * 0.4})`, 3.2 + flash * 0.9, `rgba(255, 180, 0, ${0.4 + flash * 0.3})`, enemyTransform);
      }
    }

    drawShieldPickups();
    drawExplosions();

    // 投射物描画（レーザー/ミサイル）
    drawLaserProjectiles(playerShots, "rgba(0, 255, 255, 0.95)", 2.2, 0.02);
    drawMissiles(playerMissiles);
    drawLaserProjectiles(enemyShots, "rgba(255, 90, 120, 0.95)", 1.8, 0.018);

    drawPlayerStatusOverlay(hpText, shieldText, stockText);
    drawShieldFixBanner();

    // 自機描画
    if (player.visible && gamePhase === "stage0") {
      drawStage0Thruster();
    }
    if (player.visible && gamePhase === "cityExit") {
      drawSpaceAscentEffect();
    }
    const nowFrame = performance.now();
    const invulnFlash = player.invuln > 0 && Math.floor(nowFrame * 0.02) % 2 === 0;
    if (player.visible) {
      drawInvulnAura();
    }
    if (player.visible && (!invulnFlash || gamePhase === "stage0")) {
      drawEdges(getPlayerEdges(), "rgba(0, 188, 255, 0.95)", 2.4, "rgba(0, 188, 255, 0.9)");
    }

    // ボスHPバーとステージステータス
    if (boss.active && !boss.destroyed) {
      const hpRatio = Math.max(0, boss.hp / boss.maxHp);
      const barWidth = canvas.width * 0.4;
      const barX = (canvas.width - barWidth) * 0.5;
      const barY = canvas.height * 0.12;
      ctx.fillStyle = "rgba(10, 30, 60, 0.6)";
      ctx.fillRect(barX, barY, barWidth, 12);
      const barColor = boss.variant === "battleship" ? "rgba(0, 240, 255, 0.9)" : "rgba(0, 180, 255, 0.9)";
      const frameColor = boss.variant === "battleship" ? "rgba(0, 255, 240, 0.9)" : "rgba(0, 220, 255, 0.9)";
      ctx.fillStyle = barColor;
      ctx.fillRect(barX, barY, barWidth * hpRatio, 12);
      ctx.strokeStyle = frameColor;
      ctx.strokeRect(barX, barY, barWidth, 12);
    }
    if (gamePhase === "gameOver") {
      const elapsed = (nowFrame - gameOverTime) * 0.001;
      const alpha = Math.min(1, 0.3 + elapsed * 0.4);
      ctx.fillStyle = `rgba(255, 80, 120, ${alpha})`;
      ctx.font = `${64}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", canvas.width * 0.5, canvas.height * 0.38);
      ctx.font = `${22}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.fillText("Press R to reload", canvas.width * 0.5, canvas.height * 0.45);
    } else if (stageClear) {
      const elapsed = (nowFrame - stageClearTime) * 0.001;
      const alpha = Math.min(1, 0.6 + elapsed * 0.35);
      ctx.fillStyle = `rgba(0, 255, 220, ${alpha})`;
      ctx.font = `${64}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.fillText("MISSION COMPLETE", canvas.width * 0.5, canvas.height * 0.38);
      ctx.font = `${24}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.fillText("Press R to replay (reload)", canvas.width * 0.5, canvas.height * 0.45);
    } else if (stage1Clear && gamePhase === "cityExit") {
      const alpha = Math.min(1, cityExitState.progress * 1.4);
      ctx.fillStyle = `rgba(0, 255, 200, ${alpha * 0.8})`;
      ctx.font = `${48}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.fillText("STAGE 1 CLEAR", canvas.width * 0.5, canvas.height * 0.32);
    }

    ctx.restore();
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
